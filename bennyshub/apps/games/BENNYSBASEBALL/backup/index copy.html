<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Benny's Baseball Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #000428 0%, #004e92 100%);
            overflow: hidden;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }

        #gameCanvas {
            display: block;
            background: #1a5f1a;
            margin: 0 auto;
            cursor: pointer;
        }

        .controls-info {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            font-size: 14px;
            text-align: center;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border-radius: 10px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
        }

        #pauseButton {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: linear-gradient(135deg, rgba(20, 30, 48, 0.95) 0%, rgba(10, 15, 30, 0.95) 100%);
            color: #4a9eff;
            border: 3px solid #4a9eff;
            padding: 12px 24px;
            font-size: 16px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            z-index: 1000;
            display: none;
        }

        #pauseButton:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(74, 158, 255, 0.4);
            background: linear-gradient(135deg, rgba(30, 40, 58, 0.95) 0%, rgba(20, 25, 40, 0.95) 100%);
        }

        #pauseButton:active {
            transform: translateY(0px);
        }

        #pauseButton.visible {
            display: block;
        }

        .pause-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 999;
        }

        .pause-overlay.active {
            display: flex;
        }

        .pause-menu {
            background: linear-gradient(135deg, rgba(20, 30, 48, 0.95) 0%, rgba(10, 15, 30, 0.95) 100%);
            border: 3px solid #4a9eff;
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            color: #fff;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }

        .pause-menu h2 {
            font-size: 48px;
            margin-bottom: 30px;
            color: #4a9eff;
            text-shadow: 3px 3px 0px rgba(0, 0, 0, 0.3);
        }

        .pause-menu button {
            display: block;
            width: 100%;
            padding: 15px 30px;
            margin: 15px 0;
            font-size: 24px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            background: linear-gradient(135deg, rgba(255, 235, 59, 0.2) 0%, rgba(255, 235, 59, 0.4) 50%, rgba(255, 235, 59, 0.2) 100%);
            border: 2px solid #ffeb3b;
            color: #ffeb3b;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .pause-menu button:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(255, 235, 59, 0.4);
            background: linear-gradient(135deg, rgba(255, 235, 59, 0.3) 0%, rgba(255, 235, 59, 0.5) 50%, rgba(255, 235, 59, 0.3) 100%);
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <button id="pauseButton">⏸ PAUSE</button>
    <div class="controls-info">
        SPACE: Scan Options | ENTER: Select | CLICK: Select Option
    </div>

    <!-- Pause Menu Overlay -->
    <div class="pause-overlay" id="pauseOverlay">
        <div class="pause-menu">
            <h2>⏸ PAUSED</h2>
            <button onclick="resumeGame()">Resume Game</button>
            <button onclick="restartGame()">Restart Game</button>
            <button onclick="quitToMenu()">Main Menu</button>
        </div>
    </div>

    <!-- Sound Effects -->
    <audio id="scanSound" src="data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQAAAAA="></audio>
    <audio id="selectSound" src="data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQAAAAA="></audio>
    <audio id="hitSound"></audio>
    <audio id="homerunSound"></audio>
    <audio id="bgMusic" loop></audio>

    <script>
        // ============= GAME CONSTANTS =============
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const pauseButton = document.getElementById('pauseButton');
        const pauseOverlay = document.getElementById('pauseOverlay');
        
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // ============= GAME STATE =============
        const game = {
            mode: 'MAIN_MENU',
            currentInning: 1,
            half: 'top',
            outs: 0,
            score: { Blue: 0, Red: 0 },
            bases: { first: null, second: null, third: null },
            balls: 0,
            strikes: 0,
            homeTeam: 'Blue',
            awayTeam: 'Red',
            selectedIndex: 0,
            menuOptions: [],
            menuBounds: [],
            firstPitch: true,
            selectedPitch: null,
            selectedPitchLocation: null,
            selectedSwing: null,
            samePitchCount: 0,
            lastPitchType: null,
            spaceHeld: false,
            spaceHoldStart: 0,
            lastSpaceScan: 0,
            returnHeld: false,
            returnHoldStart: 0,
            animating: false,
            speech: window.speechSynthesis,
            ballAnimation: null,
            runnerAnimation: {
                active: false,
                runners: [],
                completedAnimations: 0,
                totalAnimations: 0
            },
            lastActionTime: 0,
            actionCooldown: 500, // Minimum time between actions
            menuReady: false, // New flag to prevent rapid actions
            hasScanned: false, // Track if user has scanned at least once
            pendingBaseUpdate: null, // Store pending base update function
            playInProgress: false, // NEW: Complete play lockdown flag
            inputsBlocked: false, // NEW: Block all inputs flag
            playCompleteCooldown: 1500 // NEW: Cooldown after play completes
        };

        // ============= VISUAL SETTINGS =============
        const colors = {
            grass: '#2d5016',
            grassLight: '#3a6b1e',
            dirt: '#8b6914',
            dirtLight: '#a67c1a',
            baseLine: '#ffffff',
            playerRed: '#ff0000',
            playerBlue: '#0000ff',
            ballWhite: '#ffffff',
            strikeZone: 'rgba(255, 255, 255, 0.2)',
            menuBg: 'rgba(20, 30, 48, 0.95)',
            menuBorder: '#4a9eff',
            menuSelected: '#ffeb3b',
            menuText: '#ffffff'
        };

        // ============= PLAYER POSITIONS =============
        class Player {
            constructor(x, y, color, position) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.position = position;
                this.size = 20;
                this.animation = 0;
            }

            draw() {
                ctx.save();
                
                // Draw shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.ellipse(this.x, this.y + 12, 8, 4, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw player as retro pixel character
                ctx.fillStyle = this.color;
                
                // Head
                ctx.fillRect(this.x - 4, this.y - 16, 8, 8);
                
                // Body
                ctx.fillRect(this.x - 6, this.y - 8, 12, 10);
                
                // Arms (animated)
                const armOffset = Math.sin(this.animation) * 2;
                ctx.fillRect(this.x - 10, this.y - 6 + armOffset, 4, 8);
                ctx.fillRect(this.x + 6, this.y - 6 - armOffset, 4, 8);
                
                // Legs
                ctx.fillRect(this.x - 6, this.y + 2, 4, 8);
                ctx.fillRect(this.x + 2, this.y + 2, 4, 8);
                
                // Add number on jersey with better contrast
                ctx.fillStyle = '#000000';
                ctx.fillRect(this.x - 3, this.y - 5, 6, 6);
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 7px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(this.position, this.x, this.y - 1);
                
                this.animation += 0.05;
                ctx.restore();
            }
        }

        let fieldPlayers = [];

        // ============= AUDIO FUNCTIONS =============
        function speak(text) {
            if (game.speech) {
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.rate = 1.0;
                utterance.pitch = 1.0;
                game.speech.cancel();
                game.speech.speak(utterance);
            }
        }

        function playSound(type) {
            const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            
            if (type === 'scan') {
                oscillator.frequency.value = 440;
                gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                oscillator.start(audioCtx.currentTime);
                oscillator.stop(audioCtx.currentTime + 0.1);
            } else if (type === 'select') {
                oscillator.frequency.value = 880;
                gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
                oscillator.start(audioCtx.currentTime);
                oscillator.stop(audioCtx.currentTime + 0.15);
            }
        }

        // ============= DRAWING FUNCTIONS =============
        function drawField() {
            const cx = canvas.width / 2;
            const cy = canvas.height / 2 + 50;
            const diamondSize = Math.min(canvas.width, canvas.height) * 0.35;

            // Draw outfield with gradient
            const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, diamondSize * 2);
            gradient.addColorStop(0, colors.grassLight);
            gradient.addColorStop(1, colors.grass);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw infield dirt with gradient
            ctx.save();
            ctx.translate(cx, cy);
            ctx.rotate(Math.PI / 4);
            const dirtGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, diamondSize);
            dirtGradient.addColorStop(0, colors.dirtLight);
            dirtGradient.addColorStop(1, colors.dirt);
            ctx.fillStyle = dirtGradient;
            ctx.fillRect(-diamondSize * 0.7, -diamondSize * 0.7, diamondSize * 1.4, diamondSize * 1.4);
            ctx.restore();

            // Draw diamond lines with glow effect
            ctx.shadowColor = 'rgba(255, 255, 255, 0.5)';
            ctx.shadowBlur = 10;
            ctx.strokeStyle = colors.baseLine;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(cx, cy + diamondSize / 2);
            ctx.lineTo(cx + diamondSize / 2, cy);
            ctx.lineTo(cx, cy - diamondSize / 2);
            ctx.lineTo(cx - diamondSize / 2, cy);
            ctx.closePath();
            ctx.stroke();

            // Foul lines
            ctx.beginPath();
            ctx.moveTo(cx, cy + diamondSize / 2);
            ctx.lineTo(cx + diamondSize, cy + diamondSize);
            ctx.moveTo(cx, cy + diamondSize / 2);
            ctx.lineTo(cx - diamondSize, cy + diamondSize);
            ctx.stroke();
            ctx.shadowBlur = 0;

            // Draw pitcher's mound with 3D effect
            const moundRadius = diamondSize * 0.12;
            const moundGradient = ctx.createRadialGradient(cx, cy - 5, 0, cx, cy, moundRadius);
            moundGradient.addColorStop(0, colors.dirtLight);
            moundGradient.addColorStop(1, colors.dirt);
            ctx.fillStyle = moundGradient;
            ctx.beginPath();
            ctx.arc(cx, cy, moundRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Draw bases
            drawBases(cx, cy, diamondSize);

            // Store field coordinates
            game.fieldCoords = {
                home: { x: cx, y: cy + diamondSize / 2 },
                first: { x: cx + diamondSize / 2, y: cy },
                second: { x: cx, y: cy - diamondSize / 2 },
                third: { x: cx - diamondSize / 2, y: cy },
                pitcher: { x: cx, y: cy }
            };
            game.diamondSize = diamondSize;
        }

        function drawBases(cx, cy, size) {
            const baseSize = size * 0.08;
            const bases = [
                { name: 'home', x: cx, y: cy + size / 2 },
                { name: 'first', x: cx + size / 2, y: cy },
                { name: 'second', x: cx, y: cy - size / 2 },
                { name: 'third', x: cx - size / 2, y: cy }
            ];

            bases.forEach(base => {
                let fillColor = '#ffffff';
                
                if (base.name !== 'home') {
                    const runner = game.bases[base.name];
                    if (runner === 'user') fillColor = colors.playerRed;
                    else if (runner === 'comp') fillColor = colors.playerBlue;
                }

                // Add glow effect for occupied bases
                if (fillColor !== '#ffffff') {
                    ctx.shadowColor = fillColor;
                    ctx.shadowBlur = 15;
                }

                ctx.fillStyle = fillColor;
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;

                if (base.name === 'home') {
                    ctx.beginPath();
                    ctx.moveTo(base.x, base.y - baseSize);
                    ctx.lineTo(base.x + baseSize / 2, base.y - baseSize / 2);
                    ctx.lineTo(base.x + baseSize / 2, base.y + baseSize / 2);
                    ctx.lineTo(base.x - baseSize / 2, base.y + baseSize / 2);
                    ctx.lineTo(base.x - baseSize / 2, base.y - baseSize / 2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                } else {
                    ctx.save();
                    ctx.translate(base.x, base.y);
                    ctx.rotate(Math.PI / 4);
                    ctx.fillRect(-baseSize / 2, -baseSize / 2, baseSize, baseSize);
                    ctx.strokeRect(-baseSize / 2, -baseSize / 2, baseSize, baseSize);
                    ctx.restore();
                }
                
                ctx.shadowBlur = 0;
            });
        }

        function drawScoreboard() {
            const padding = 20;
            const fontSize = 24;
            
            ctx.font = `bold ${fontSize}px monospace`;
            ctx.textAlign = 'center';
            ctx.fillStyle = '#ffffff';
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 3;

            // Inning and Outs at top with background
            const topText = `INNING: ${game.half.toUpperCase()} ${game.currentInning}       OUTS: ${game.outs}/3`;
            const topWidth = ctx.measureText(topText).width + 40;
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(canvas.width / 2 - topWidth / 2, 15, topWidth, 40);
            
            ctx.fillStyle = '#ffffff';
            ctx.strokeText(topText, canvas.width / 2, 40);
            ctx.fillText(topText, canvas.width / 2, 40);

            // Score display - LARGE retro style with backgrounds
            const scoreSize = 120;
            ctx.font = `bold ${scoreSize}px monospace`;
            
            // Player score (Red) on left
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(canvas.width * 0.2 - 80, 70, 160, 120);
            
            ctx.fillStyle = colors.playerRed;
            ctx.shadowColor = colors.playerRed;
            ctx.shadowBlur = 20;
            ctx.strokeText(game.score.Red.toString(), canvas.width * 0.2, 150);
            ctx.fillText(game.score.Red.toString(), canvas.width * 0.2, 150);
            ctx.shadowBlur = 0;
            
            // Computer score (Blue) on right
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(canvas.width * 0.8 - 80, 70, 160, 120);
            
            ctx.fillStyle = colors.playerBlue;
            ctx.shadowColor = colors.playerBlue;
            ctx.shadowBlur = 20;
            ctx.strokeText(game.score.Blue.toString(), canvas.width * 0.8, 150);
            ctx.fillText(game.score.Blue.toString(), canvas.width * 0.8, 150);
            ctx.shadowBlur = 0;

            // Visual Count Display - Strikes and Balls
            if (game.mode === 'BATTING' || game.mode === 'PITCHING') {
                drawCountIndicators();
            }
        }

        function drawCountIndicators() {
            const countX = canvas.width - 120;
            const countY = canvas.height - 140;
            const indicatorSize = 16;
            const spacing = 12;
            
            // Background panel for count - adjusted for horizontal layout
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(countX - 60, countY - 20, 120, 80);
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.strokeRect(countX - 60, countY - 20, 120, 80);
            
            // Strikes label
            ctx.font = 'bold 12px monospace';
            ctx.fillStyle = '#ffffff';
            ctx.textAlign = 'center';
            ctx.fillText('STRIKES', countX, countY - 5);
            
            // Draw 3 diamond-shaped strike indicators (horizontally)
            const activeStrikeColor = '#ff4444';
            const inactiveStrikeColor = 'rgba(255, 68, 68, 0.2)';
            
            for (let i = 0; i < 3; i++) {
                const strikeX = countX - 24 + i * (indicatorSize + spacing);
                const strikeY = countY + 15;
                const isActive = i < game.strikes;
                
                ctx.fillStyle = isActive ? activeStrikeColor : inactiveStrikeColor;
                ctx.strokeStyle = isActive ? '#ff0000' : '#666666';
                ctx.lineWidth = 1;
                
                // Draw diamond shape
                ctx.beginPath();
                ctx.moveTo(strikeX, strikeY - indicatorSize / 2);
                ctx.lineTo(strikeX + indicatorSize / 2, strikeY);
                ctx.lineTo(strikeX, strikeY + indicatorSize / 2);
                ctx.lineTo(strikeX - indicatorSize / 2, strikeY);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                // Add glow effect for active strikes
                if (isActive) {
                    ctx.shadowColor = activeStrikeColor;
                    ctx.shadowBlur = 8;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
            }
            
            // Balls label
            const ballsStartY = countY + 40;
            ctx.fillStyle = '#ffffff';
            ctx.fillText('BALLS', countX, ballsStartY - 5);
            
            // Draw 4 circular ball indicators (horizontally)
            const activeBallColor = '#ffffff';
            const inactiveBallColor = 'rgba(255, 255, 255, 0.2)';
            
            for (let i = 0; i < 4; i++) {
                const ballX = countX - 36 + i * (indicatorSize + spacing);
                const ballY = ballsStartY + 10;
                const isActive = i < game.balls;
                
                ctx.fillStyle = isActive ? activeBallColor : inactiveBallColor;
                ctx.strokeStyle = isActive ? '#cccccc' : '#666666';
                ctx.lineWidth = 1;
                
                // Draw circle
                ctx.beginPath();
                ctx.arc(ballX, ballY, indicatorSize / 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                
                // Add glow effect for active balls
                if (isActive) {
                    ctx.shadowColor = activeBallColor;
                    ctx.shadowBlur = 6;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
            }
        }

        function drawPlayers() {
            fieldPlayers.forEach(player => player.draw());
        }

        function initializeFieldPlayers() {
            if (!game.fieldCoords) return;
            
            const coords = game.fieldCoords;
            const size = game.diamondSize;
            fieldPlayers = [];

            const positions = [
                { pos: 'P', x: coords.pitcher.x, y: coords.pitcher.y, color: colors.playerBlue },
                { pos: 'C', x: coords.home.x, y: coords.home.y + 40, color: colors.playerBlue },
                { pos: '1B', x: coords.first.x + 30, y: coords.first.y + 30, color: colors.playerBlue },
                { pos: '2B', x: coords.second.x + size * 0.2, y: coords.second.y + size * 0.2, color: colors.playerBlue },
                { pos: 'SS', x: coords.second.x - size * 0.2, y: coords.second.y + size * 0.2, color: colors.playerBlue },
                { pos: '3B', x: coords.third.x - 30, y: coords.third.y + 30, color: colors.playerBlue },
                { pos: 'LF', x: coords.third.x - size * 0.5, y: coords.third.y - size * 0.3, color: colors.playerBlue },
                { pos: 'CF', x: coords.second.x, y: coords.second.y - size * 0.6, color: colors.playerBlue },
                { pos: 'RF', x: coords.first.x + size * 0.5, y: coords.first.y - size * 0.3, color: colors.playerBlue }
            ];

            positions.forEach(p => {
                fieldPlayers.push(new Player(p.x, p.y, p.color, p.pos));
            });

            const batterColor = game.half === 'top' ? colors.playerRed : colors.playerBlue;
            fieldPlayers.push(new Player(coords.home.x - 40, coords.home.y, batterColor, 'BAT'));
        }

        function drawBallAnimation(from, to, callback) {
            drawBallArc(from, to, 800, callback);
        }

        function drawGameScreen() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawField();
            drawPlayers();
            drawScoreboard();
        }

        // ============= MENU DRAWING WITH BOUNDS =============
        function drawSwingMenu() {
            drawGameScreen();
            
            const padding = 20;
            const itemHeight = 50;
            const menuWidth = 280;
            const menuHeight = game.menuOptions.length * itemHeight + padding * 2;
            const menuX = 30;
            const menuY = Math.max(padding, Math.min(
                canvas.height / 2 - menuHeight / 2,
                canvas.height - menuHeight - padding
            ));

            game.menuBounds = [];

            // Modern menu background with gradient
            const gradient = ctx.createLinearGradient(menuX, menuY, menuX, menuY + menuHeight);
            gradient.addColorStop(0, colors.menuBg);
            gradient.addColorStop(1, 'rgba(10, 15, 30, 0.95)');
            ctx.fillStyle = gradient;
            ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
            ctx.shadowBlur = 20;
            ctx.fillRect(menuX, menuY, menuWidth, menuHeight);
            ctx.shadowBlur = 0;

            // Modern border
            ctx.strokeStyle = colors.menuBorder;
            ctx.lineWidth = 3;
            ctx.strokeRect(menuX, menuY, menuWidth, menuHeight);

            // Menu options
            ctx.font = 'bold 18px monospace';
            ctx.textAlign = 'left';
            
            game.menuOptions.forEach((option, i) => {
                const itemY = menuY + padding + i * itemHeight;
                const isSelected = i === game.selectedIndex;
                
                // Store bounds for click detection
                game.menuBounds.push({
                    x: menuX,
                    y: itemY,
                    width: menuWidth,
                    height: itemHeight
                });
                
                // Selection highlight with modern gradient
                if (isSelected) {
                    const selGradient = ctx.createLinearGradient(menuX + 5, itemY, menuX + menuWidth - 5, itemY);
                    selGradient.addColorStop(0, 'rgba(255, 235, 59, 0.2)');
                    selGradient.addColorStop(0.5, 'rgba(255, 235, 59, 0.4)');
                    selGradient.addColorStop(1, 'rgba(255, 235, 59, 0.2)');
                    ctx.fillStyle = selGradient;
                    ctx.fillRect(menuX + 5, itemY + 5, menuWidth - 10, itemHeight - 10);
                    
                    ctx.strokeStyle = colors.menuSelected;
                    ctx.lineWidth = 2;
                    ctx.strokeRect(menuX + 5, itemY + 5, menuWidth - 10, itemHeight - 10);
                }
                
                // Text
                ctx.fillStyle = isSelected ? colors.menuSelected : colors.menuText;
                ctx.textBaseline = 'middle';
                ctx.fillText(isSelected ? `▶ ${option}` : `  ${option}`, menuX + 20, itemY + itemHeight / 2);
            });
        }

        function drawPitchMenu() {
            drawGameScreen();
            
            const padding = 20;
            const itemHeight = 50;
            const menuWidth = 280;
            const menuHeight = game.menuOptions.length * itemHeight + padding * 2;
            const menuX = 30;
            const menuY = Math.max(padding, Math.min(
                canvas.height / 2 - menuHeight / 2,
                canvas.height - menuHeight - padding
            ));

            game.menuBounds = [];

            // Modern menu background
            const gradient = ctx.createLinearGradient(menuX, menuY, menuX, menuY + menuHeight);
            gradient.addColorStop(0, colors.menuBg);
            gradient.addColorStop(1, 'rgba(10, 15, 30, 0.95)');
            ctx.fillStyle = gradient;
            ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
            ctx.shadowBlur = 20;
            ctx.fillRect(menuX, menuY, menuWidth, menuHeight);
            ctx.shadowBlur = 0;

            ctx.strokeStyle = colors.menuBorder;
            ctx.lineWidth = 3;
            ctx.strokeRect(menuX, menuY, menuWidth, menuHeight);

            // Menu title
            ctx.font = 'bold 20px monospace';
            ctx.fillStyle = colors.menuBorder;
            ctx.textAlign = 'center';
            ctx.fillText('CHOOSE PITCH', menuX + menuWidth / 2, menuY - 10);

            ctx.font = 'bold 18px monospace';
            ctx.textAlign = 'left';
            
            game.menuOptions.forEach((option, i) => {
                const itemY = menuY + padding + i * itemHeight;
                const isSelected = i === game.selectedIndex;
                
                game.menuBounds.push({
                    x: menuX,
                    y: itemY,
                    width: menuWidth,
                    height: itemHeight
                });
                
                if (isSelected) {
                    const selGradient = ctx.createLinearGradient(menuX + 5, itemY, menuX + menuWidth - 5, itemY);
                    selGradient.addColorStop(0, 'rgba(255, 235, 59, 0.2)');
                    selGradient.addColorStop(0.5, 'rgba(255, 235, 59, 0.4)');
                    selGradient.addColorStop(1, 'rgba(255, 235, 59, 0.2)');
                    ctx.fillStyle = selGradient;
                    ctx.fillRect(menuX + 5, itemY + 5, menuWidth - 10, itemHeight - 10);
                    
                    ctx.strokeStyle = colors.menuSelected;
                    ctx.lineWidth = 2;
                    ctx.strokeRect(menuX + 5, itemY + 5, menuWidth - 10, itemHeight - 10);
                }
                
                ctx.fillStyle = isSelected ? colors.menuSelected : colors.menuText;
                ctx.textBaseline = 'middle';
                ctx.fillText(isSelected ? `▶ ${option}` : `  ${option}`, menuX + 20, itemY + itemHeight / 2);
            });
        }

        // ============= GAME LOGIC =============
        function resetGameState() {
            game.currentInning = 1;
            game.half = 'top';
            game.outs = 0;
            game.score = { Blue: 0, Red: 0 };
            game.bases = { first: null, second: null, third: null };
            game.balls = 0;
            game.strikes = 0;
            game.firstPitch = true;
            game.samePitchCount = 0;
            game.lastPitchType = null;
        }

        function startGame() {
            resetGameState();
            game.mode = 'GAMEPLAY';
            pauseButton.classList.add('visible');
            drawGameScreen();
            initializeFieldPlayers();
            setTimeout(() => nextPlay(), 1000);
        }

        function nextPlay() {
            if (game.firstPitch) {
                announceHalfInning();
                return;
            }

            if (game.outs >= 3) {
                endHalfInning();
            } else {
                if (game.half === 'top') {
                    startBattingPhase();
                } else {
                    startPitchingPhase();
                }
            }
        }

        function announceHalfInning() {
            const ordinals = ['', 'First', 'Second', 'Third', 'Fourth', 'Fifth', 'Sixth', 'Seventh', 'Eighth', 'Ninth'];
            const inningText = ordinals[game.currentInning] || game.currentInning;
            const halfText = game.half === 'top' ? 'Top' : 'Bottom';
            const outsText = ['zero outs', 'one out', 'two outs', 'three outs'][game.outs];
            
            speak(`${halfText} of the ${inningText} inning. ${outsText}.`);
            game.firstPitch = false;
            
            setTimeout(() => nextPlay(), 4000); // Increased from 2000 to 4000 for TTS to finish
        }

        function startBattingPhase() {
            game.mode = 'BATTING';
            simulateComputerPitch();
            speak("Pitcher throws the ball.");
            
            setTimeout(() => showSwingMenu(), 1500);
        }

        function simulateComputerPitch() {
            const pitchTypes = ['Fastball', 'Curveball', 'Slider', 'Knuckleball', 'Changeup'];
            const locations = ['Inside', 'Middle', 'Outside'];
            game.selectedPitch = pitchTypes[Math.floor(Math.random() * pitchTypes.length)];
            game.selectedPitchLocation = locations[Math.floor(Math.random() * locations.length)];
        }

        function showSwingMenu() {
            game.menuOptions = ['Normal Swing', 'Power Swing', 'Hold', 'Bunt'];
            
            if (game.bases.first && !game.bases.second) {
                game.menuOptions.push('Steal 2nd Base');
            }
            if (game.bases.second && !game.bases.third) {
                game.menuOptions.push('Steal 3rd Base');
            }
            
            game.selectedIndex = -1; // Require spacebar press first
            game.menuReady = false; // Reset menu readiness
            game.hasScanned = false; // Reset scan flag
            drawSwingMenu();
        }

        function processBattingSelection(selected) {
            const option = game.menuOptions[selected];
            let outcome = null;
            let terminal = false;

            if (option.includes('Steal')) {
                const base = option.includes('2nd') ? 'second' : 'third';
                const success = Math.random() < (base === 'second' ? 0.5 : 0.3);
                
                if (success) {
                    const fromBase = base === 'second' ? 'first' : 'second';
                    
                    // Store the base update to execute after animation
                    game.pendingBaseUpdate = () => {
                        game.bases[base] = game.bases[fromBase];
                        game.bases[fromBase] = null;
                    };
                    
                    speak(`Steal successful!`);
                    
                    // Animate runner stealing base
                    const stealOutcome = base === 'second' ? 'Steal Second' : 'Steal Third';
                    startRunnerAnimation(stealOutcome, () => finishPlay(null));
                } else {
                    game.bases[base === 'second' ? 'first' : 'second'] = null;
                    game.outs++;
                    speak(`Steal failed. Runner is out.`);
                    finishPlay(null);
                }
                terminal = true;
            } else if (option === 'Bunt') {
                // Bunt probabilities: 40% out, 30% foul, 30% single
                const rand = Math.random();
                if (rand < 0.4) {
                    outcome = 'Ground Out';
                } else if (rand < 0.7) {
                    outcome = 'Foul';
                } else {
                    outcome = 'Single';
                }
                
                terminal = outcome !== 'Foul';
                
                if (outcome === 'Ground Out') {
                    // Batter is out, but runners advance
                    game.outs++;
                    
                    // Store the base update to execute after animation - runners advance
                    game.pendingBaseUpdate = () => {
                        if (game.bases.second) game.bases.third = game.bases.second;
                        if (game.bases.first) game.bases.second = game.bases.first;
                        game.bases.first = null; // Batter is out, doesn't reach first
                    };
                } else if (outcome === 'Single') {
                    // Store the base update to execute after animation - bunt single
                    game.pendingBaseUpdate = () => {
                        if (game.bases.second) game.bases.third = game.bases.second;
                        if (game.bases.first) game.bases.second = game.bases.first;
                        game.bases.first = 'user'; // Batter reaches first
                    };
                } else if (outcome === 'Foul') {
                    // Foul ball - count as strike if less than 2 strikes
                    if (game.strikes < 2) game.strikes++;
                }
                
                if (outcome === 'Foul') {
                    // Just show foul ball animation, no base running
                    const from = { x: game.fieldCoords.home.x - 40, y: game.fieldCoords.home.y };
                    const to = { x: Math.random() < 0.5 ? 100 : canvas.width - 100, y: canvas.height - 100 };
                    drawBallAnimation(from, to, () => finishPlay(outcome));
                } else {
                    // Show ball animation first, then runner animation for single/out
                    const from = { x: game.fieldCoords.home.x - 40, y: game.fieldCoords.home.y };
                    const to = { x: game.fieldCoords.first.x + 50, y: game.fieldCoords.first.y + 50 };
                    
                    drawBallAnimation(from, to, () => {
                        if (outcome === 'Single') {
                            startRunnerAnimation('Single', () => finishPlay(outcome));
                        } else {
                            // For Ground Out, still animate any base runners advancing
                            if (game.bases.first || game.bases.second) {
                                startRunnerAnimation('Bunt Advance', () => finishPlay(outcome));
                            } else {
                                finishPlay(outcome);
                            }
                        }
                    });
                }
            } else {
                outcome = simulateBatting(option);
                terminal = ['Single', 'Double', 'Triple', 'Home Run', 'Walk', 'Strike Out', 'Pop Fly Out', 'Ground Out'].includes(outcome);
                
                processBattingOutcome(outcome, terminal);
            }
        }

        function simulateBatting(swing) {
            if (swing === 'Hold') {
                return game.selectedPitchLocation === 'Outside' ? 'Ball' : (Math.random() < 0.6 ? 'Ball' : 'Strike');
            }
            
            const weights = swing === 'Power Swing' ? 
                { Strike: 55, Foul: 10, 'Pop Fly Out': 15, 'Home Run': 8, Double: 7, Single: 5 } :
                { Strike: 35, Foul: 20, 'Pop Fly Out': 10, 'Ground Out': 10, Single: 18, Double: 7, Triple: 4, 'Home Run': 1 };
            
            return weightedChoice(weights);
        }

        function processBattingOutcome(outcome, terminal) {
            speak(`Result: ${outcome}`);
            
            if (outcome === 'Strike') {
                game.strikes++;
                if (game.strikes >= 3) {
                    outcome = 'Strike Out';
                    game.outs++;
                    terminal = true;
                }
            } else if (outcome === 'Ball') {
                game.balls++;
                if (game.balls >= 4) {
                    outcome = 'Walk';
                    // Store the base update to execute after animation (though Walk doesn't animate)
                    updateBases('Walk', 'user');
                    terminal = true;
                }
            } else if (outcome === 'Foul') {
                if (game.strikes < 2) game.strikes++;
            } else if (['Pop Fly Out', 'Ground Out'].includes(outcome)) {
                if (outcome === 'Ground Out' && game.bases.first && Math.random() < 0.5) {
                    game.outs += 2;
                    game.bases.first = null;
                    outcome = 'Double Play';
                } else {
                    game.outs++;
                }
            } else if (['Single', 'Double', 'Triple', 'Home Run'].includes(outcome)) {
                // Store the base update to execute after animation
                game.pendingBaseUpdate = () => {
                    updateBases(outcome, 'user');
                };
            }

            if (terminal) {
                game.balls = 0;
                game.strikes = 0;
            }

            if (['Single', 'Double', 'Triple', 'Home Run', 'Pop Fly Out', 'Foul'].includes(outcome)) {
                const from = game.fieldCoords.home;
                let to = game.fieldCoords.second;
                
                if (outcome === 'Home Run') {
                    to = { x: canvas.width / 2, y: 100 };
                } else if (outcome === 'Foul') {
                    to = { x: Math.random() < 0.5 ? 100 : canvas.width - 100, y: canvas.height - 100 };
                }
                
                // Show ball animation first, then runner animation for hits
                drawBallFlightAndThrow(from, outcome, () => {
                    if (['Single', 'Double', 'Triple', 'Home Run'].includes(outcome)) {
                        // Start runner animation after ball animation completes
                        startRunnerAnimation(outcome, () => finishPlay(outcome));
                    } else {
                        finishPlay(outcome);
                    }
                });
            } else {
                finishPlay(outcome);
            }
        }

        function startPitchingPhase() {
            game.mode = 'PITCHING';
            showPitchMenu();
        }

        function showPitchMenu() {
            game.menuOptions = ['Fastball', 'Curveball', 'Slider', 'Knuckleball', 'Changeup'];
            game.selectedIndex = -1; // Require spacebar press first
            game.menuReady = false; // Reset menu readiness
            game.hasScanned = false; // Reset scan flag
            drawPitchMenu();
            speak("Choose your pitch.");
        }

        function processPitchSelection(selected) {
            const pitchType = game.menuOptions[selected];
            game.selectedPitch = pitchType;
            
            if (game.lastPitchType === pitchType) {
                game.samePitchCount++;
            } else {
                game.samePitchCount = 1;
            }
            game.lastPitchType = pitchType;
            
            const locations = ['Inside', 'Middle', 'Outside'];
            game.selectedPitchLocation = locations[Math.floor(Math.random() * locations.length)];
            
            speak(`Pitch: ${pitchType} ${game.selectedPitchLocation}`);
            
            setTimeout(() => processPitch(pitchType), 1000);
        }

        function processPitch(pitchType) {
            const probabilities = {
                Fastball: { strike: 45, ball: 20, hit: 35 },
                Curveball: { strike: 40, ball: 25, hit: 35 },
                Slider: { strike: 45, ball: 30, hit: 25 },
                Knuckleball: { strike: 40, ball: 30, hit: 30 },
                Changeup: { strike: 40, ball: 22, hit: 38 }
            };
            
            let { strike, ball, hit } = probabilities[pitchType] || probabilities.Fastball;
            
            if (game.samePitchCount > 2) {
                hit += 10 * (game.samePitchCount - 2);
            }
            
            const total = strike + ball + hit;
            const rand = Math.random() * total;
            
            let outcome;
            if (rand < strike) {
                outcome = 'Strike';
            } else if (rand < strike + ball) {
                outcome = 'Ball';
            } else {
                const hitWeights = { Single: 20, Double: 5, Triple: 2, 'Home Run': 1, 'Pop Fly Out': 10, 'Ground Out': 15 };
                outcome = weightedChoice(hitWeights);
            }
            
            processPitchOutcome(outcome);
        }

        function processPitchOutcome(outcome) {
            let terminal = false;
            speak(`Computer batter: ${outcome}`);
            
            if (outcome === 'Strike') {
                game.strikes++;
                if (game.strikes >= 3) {
                    outcome = 'Strike Out';
                    game.outs++;
                    terminal = true;
                }
            } else if (outcome === 'Ball') {
                game.balls++;
                if (game.balls >= 4) {
                    outcome = 'Walk';
                    updateBases('Walk', 'comp');
                    terminal = true;
                }
            } else if (outcome === 'Foul') {
                if (game.strikes < 2) game.strikes++;
            } else if (['Pop Fly Out', 'Ground Out'].includes(outcome)) {
                if (outcome === 'Ground Out' && game.bases.first && Math.random() < 0.5) {
                    game.outs += 2;
                    game.bases.first = null;
                    outcome = 'Double Play';
                } else {
                    game.outs++;
                }
                terminal = true;
            } else if (['Single', 'Double', 'Triple', 'Home Run'].includes(outcome)) {
                updateBases(outcome, 'comp');
                terminal = true;
            }

            if (terminal) {
                game.balls = 0;
                game.strikes = 0;
            }

            if (['Single', 'Double', 'Triple', 'Home Run', 'Pop Fly Out', 'Foul'].includes(outcome)) {
                const from = game.fieldCoords.home;
                let to = game.fieldCoords.second;
                
                if (outcome === 'Home Run') {
                    to = { x: canvas.width / 2, y: 100 };
                }
                
                drawBallFlightAndThrow(from, outcome, () => finishPlay(outcome));
            } else {
                finishPlay(outcome);
            }
        }

        function updateBases(outcome, batter) {
            const team = game.half === 'top' ? 'Red' : 'Blue';
            
            if (outcome === 'Single') {
                if (game.bases.third) game.score[team]++;
                game.bases.third = game.bases.second;
                game.bases.second = game.bases.first;
                game.bases.first = batter;
            } else if (outcome === 'Walk') {
                if (game.bases.first) {
                    if (game.bases.second) {
                        if (game.bases.third) game.score[team]++;
                        game.bases.third = game.bases.second;
                    }
                    game.bases.second = game.bases.first;
                }
                game.bases.first = batter;
            } else if (outcome === 'Double') {
                if (game.bases.third) game.score[team]++;
                if (game.bases.second) game.score[team]++;
                game.bases.third = game.bases.first;
                game.bases.first = null;
                game.bases.second = batter;
            } else if (outcome === 'Triple') {
                ['first', 'second', 'third'].forEach(base => {
                    if (game.bases[base]) {
                        game.score[team]++;
                        game.bases[base] = null;
                    }
                });
                game.bases.third = batter;
            } else if (outcome === 'Home Run') {
                let runs = 1;
                ['first', 'second', 'third'].forEach(base => {
                    if (game.bases[base]) {
                        runs++;
                        game.bases[base] = null;
                    }
                });
                game.score[team] += runs;
            }
        }

        function finishPlay(outcome) {
            drawGameScreen();
            
            // Schedule the unlocking of inputs after play completes with cooldown
            setTimeout(() => {
                unlockInputsAfterPlay();
                
                if (game.outs >= 3) {
                    endHalfInning();
                } else {
                    nextPlay();
                }
            }, 2000);
        }

        function unlockInputsAfterPlay() {
            // Add additional cooldown before unlocking inputs
            setTimeout(() => {
                game.playInProgress = false;
                game.inputsBlocked = false;
                game.menuReady = false;
                game.hasScanned = false;
                game.selectedIndex = -1;
            }, game.playCompleteCooldown);
        }

        function endHalfInning() {
            speak(`Half inning over with ${game.outs} outs.`);
            game.outs = 0;
            game.bases = { first: null, second: null, third: null };
            game.balls = 0;
            game.strikes = 0;

            if (game.half === 'top') {
                if (game.currentInning >= 9 && game.score.Blue > game.score.Red) {
                    endGame();
                    return;
                }
                game.half = 'bottom';
            } else {
                if (game.currentInning >= 9) {
                    if (game.score.Blue > game.score.Red || game.score.Red > game.score.Blue) {
                        endGame();
                        return;
                    }
                    game.currentInning++;
                    game.half = 'top';
                } else {
                    game.half = 'top';
                    game.currentInning++;
                }
            }

            game.firstPitch = true;
            setTimeout(() => nextPlay(), 4000); // Increased from 1000 to 4000 for TTS to finish
        }

        function endGame() {
            game.mode = 'GAME_OVER';
            pauseButton.classList.remove('visible');
            const playerWon = game.score.Red > game.score.Blue;
            
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.font = 'bold 80px monospace';
            ctx.textAlign = 'center';
            ctx.fillStyle = playerWon ? '#00ff00' : '#ff0000';
            ctx.shadowColor = ctx.fillStyle;
            ctx.shadowBlur = 30;
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 4;
            
            const resultText = playerWon ? 'YOU WON!' : 'YOU LOST!';
            ctx.strokeText(resultText, canvas.width / 2, canvas.height / 2);
            ctx.fillText(resultText, canvas.width / 2, canvas.height / 2);
            
            ctx.font = 'bold 36px monospace';
            ctx.fillStyle = '#ffffff';
            ctx.shadowBlur = 10;
            const finalScore = `Final Score: ${game.score.Red} - ${game.score.Blue}`;
            ctx.strokeText(finalScore, canvas.width / 2, canvas.height / 2 + 60);
            ctx.fillText(finalScore, canvas.width / 2, canvas.height / 2 + 60);
            ctx.shadowBlur = 0;
            
            speak(resultText);
            
            setTimeout(() => showMainMenu(), 5000);
        }

        function weightedChoice(weights) {
            const total = Object.values(weights).reduce((a, b) => a + b, 0);
            let rand = Math.random() * total;
            
            for (const [outcome, weight] of Object.entries(weights)) {
                rand -= weight;
                if (rand <= 0) return outcome;
            }
            
            return Object.keys(weights)[0];
        }

        // ============= MAIN MENU =============
        function showMainMenu() {
            game.mode = 'MAIN_MENU';
            game.menuOptions = ['Play Game', 'Exit Game'];
            game.selectedIndex = 0;
            pauseButton.classList.remove('visible');
            
            drawMainMenu();
            speak("Benny's Baseball Game");
        }

        function drawMainMenu() {
            // Modern gradient background
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#000428');
            gradient.addColorStop(1, '#004e92');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            drawField();
            
            // Title with modern effects
            ctx.font = 'bold 60px monospace';
            ctx.textAlign = 'center';
            ctx.fillStyle = '#ffffff';
            ctx.shadowColor = '#ff0000';
            ctx.shadowBlur = 30;
            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = 4;
            ctx.strokeText("BENNY'S BASEBALL", canvas.width / 2, 100);
            ctx.fillText("BENNY'S BASEBALL", canvas.width / 2, 100);
            
            // Menu options with bounds
            const menuY = canvas.height / 2 + 100;
            const menuItemHeight = 60;
            game.menuBounds = [];
            
            ctx.font = 'bold 36px monospace';
            game.menuOptions.forEach((option, i) => {
                const y = menuY + i * menuItemHeight;
                const isSelected = i === game.selectedIndex;
                
                const textWidth = ctx.measureText(option).width;
                game.menuBounds.push({
                    x: canvas.width / 2 - textWidth / 2 - 20,
                    y: y - 35,
                    width: textWidth + 40,
                    height: 50
                });
                
                if (isSelected) {
                    ctx.fillStyle = '#ffff00';
                    ctx.shadowColor = '#ffff00';
                    ctx.shadowBlur = 20;
                } else {
                    ctx.fillStyle = '#ffffff';
                    ctx.shadowBlur = 0;
                }
                
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 3;
                ctx.strokeText(option, canvas.width / 2, y);
                ctx.fillText(option, canvas.width / 2, y);
            });
            ctx.shadowBlur = 0;
        }

        // ============= PAUSE MENU FUNCTIONS =============
        pauseButton.addEventListener('click', () => {
            if (game.mode === 'GAMEPLAY' || game.mode === 'BATTING' || game.mode === 'PITCHING') {
                pauseOverlay.classList.add('active');
                speak('Game paused');
            }
        });

        function resumeGame() {
            pauseOverlay.classList.remove('active');
            speak('Resuming game');
            if (game.mode === 'BATTING') {
                drawSwingMenu();
            } else if (game.mode === 'PITCHING') {
                drawPitchMenu();
            } else {
                drawGameScreen();
            }
        }

        function restartGame() {
            pauseOverlay.classList.remove('active');
            speak('Restarting game');
            startGame();
        }

        function quitToMenu() {
            pauseOverlay.classList.remove('active');
            speak('Returning to main menu');
            showMainMenu();
        }

        // ============= INPUT HANDLING =============
        let keyStates = {};

        window.addEventListener('keydown', (e) => {
            if (keyStates[e.key]) return;
            keyStates[e.key] = true;

            if (e.key === ' ') {
                e.preventDefault();
                game.spaceHeld = true;
                game.spaceHoldStart = Date.now();
            }

            if (e.key === 'Enter') {
                e.preventDefault();
                game.returnHeld = true;
                game.returnHoldStart = Date.now();
            }
        });

        window.addEventListener('keyup', (e) => {
            keyStates[e.key] = false;

            if (e.key === ' ') {
                e.preventDefault();
                game.spaceHeld = false;
                handleSpaceRelease();
            }

            if (e.key === 'Enter') {
                e.preventDefault();
                game.returnHeld = false;
                handleEnterRelease();
            }
        });

        function handleSpaceRelease() {
            // COMPLETE INPUT LOCKDOWN - Block all inputs during play execution
            if (game.playInProgress || game.inputsBlocked) {
                return;
            }
            
            const now = Date.now();
            if (now - game.lastSpaceScan < 200) return;
            
            game.lastSpaceScan = now;
            playSound('scan');
            
            if (game.mode === 'MAIN_MENU') {
                game.selectedIndex = (game.selectedIndex + 1) % game.menuOptions.length;
                drawMainMenu();
                speak(game.menuOptions[game.selectedIndex]);
            } else if (game.mode === 'BATTING') {
                if (game.selectedIndex === -1) {
                    game.selectedIndex = 0;
                } else {
                    game.selectedIndex = (game.selectedIndex + 1) % game.menuOptions.length;
                }
                game.hasScanned = true;
                game.menuReady = true;
                drawSwingMenu();
                speak(game.menuOptions[game.selectedIndex]);
            } else if (game.mode === 'PITCHING') {
                if (game.selectedIndex === -1) {
                    game.selectedIndex = 0;
                } else {
                    game.selectedIndex = (game.selectedIndex + 1) % game.menuOptions.length;
                }
                game.hasScanned = true;
                game.menuReady = true;
                drawPitchMenu();
                speak(game.menuOptions[game.selectedIndex]);
            }
        }

        function handleEnterRelease() {
            // COMPLETE INPUT LOCKDOWN - Block all inputs during play execution
            if (game.playInProgress || game.inputsBlocked) {
                return;
            }
            
            const now = Date.now();
            const holdDuration = now - game.returnHoldStart;
            
            // Check for action cooldown to prevent rapid auto-play
            if (now - game.lastActionTime < game.actionCooldown) {
                return;
            }
            
            // Check for long press (3+ seconds) to open pause menu
            if (holdDuration >= 3000 && (game.mode === 'GAMEPLAY' || game.mode === 'BATTING' || game.mode === 'PITCHING')) {
                pauseOverlay.classList.add('active');
                speak('Game paused');
                return;
            }
            
            // STRICT BLOCKING: Only allow Enter in very specific conditions
            
            // Main menu - always allow
            if (game.mode === 'MAIN_MENU') {
                game.lastActionTime = now;
                playSound('select');
                if (game.menuOptions[game.selectedIndex] === 'Play Game') {
                    startGame();
                } else {
                    window.close();
                }
                return;
            }
            
            // Batting/Pitching - ONLY allow if all conditions are met
            if (game.mode === 'BATTING' || game.mode === 'PITCHING') {
                // Must have a valid selection
                if (game.selectedIndex === -1) {
                    return;
                }
                
                // Must have scanned at least once
                if (!game.hasScanned) {
                    return;
                }
                
                // Must be in ready state
                if (!game.menuReady) {
                    return;
                }
                
                // Must not be animating
                if (game.animating) {
                    return;
                }
                
                // LOCK DOWN INPUTS IMMEDIATELY
                game.playInProgress = true;
                game.inputsBlocked = true;
                
                // All conditions met - allow action
                game.lastActionTime = now;
                playSound('select');
                
                if (game.mode === 'BATTING') {
                    processBattingSelection(game.selectedIndex);
                } else if (game.mode === 'PITCHING') {
                    processPitchSelection(game.selectedIndex);
                }
                return;
            }
            
            // All other modes - block completely
            return;
        }

        // ============= CLICK/TOUCH HANDLING =============
        canvas.addEventListener('click', handleCanvasClick);
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            handleClick(touch.clientX - rect.left, touch.clientY - rect.top);
        });

        function handleCanvasClick(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            handleClick(x, y);
        }

        function handleClick(x, y) {
            // COMPLETE INPUT LOCKDOWN - Block all clicks during play execution
            if (game.playInProgress || game.inputsBlocked) {
                return;
            }
            
            if (game.menuBounds.length === 0) return;

            // Check if click is within any menu item bounds
            for (let i = 0; i < game.menuBounds.length; i++) {
                const bounds = game.menuBounds[i];
                if (x >= bounds.x && x <= bounds.x + bounds.width &&
                    y >= bounds.y && y <= bounds.y + bounds.height) {
                    
                    const now = Date.now();
                    
                    // Apply same protection as Enter key handling
                    if (game.mode === 'MAIN_MENU') {
                        // Main menu - always allow
                        playSound('select');
                        game.selectedIndex = i;
                        if (game.menuOptions[i] === 'Play Game') {
                            startGame();
                        } else {
                            window.close();
                        }
                        return;
                    }
                    
                    // Batting/Pitching - apply same strict checks as Enter key
                    if (game.mode === 'BATTING' || game.mode === 'PITCHING') {
                        // Check for action cooldown
                        if (now - game.lastActionTime < game.actionCooldown) {
                            return;
                        }
                        
                        // Must not be animating
                        if (game.animating) {
                            return;
                        }
                        
                        // LOCK DOWN INPUTS IMMEDIATELY
                        game.playInProgress = true;
                        game.inputsBlocked = true;
                        
                        // All conditions met - allow action
                        game.lastActionTime = now;
                        playSound('select');
                        game.selectedIndex = i;
                        
                        // Set scan flags since clicking counts as making a selection
                        game.hasScanned = true;
                        game.menuReady = true;
                        
                        if (game.mode === 'BATTING') {
                            processBattingSelection(i);
                        } else if (game.mode === 'PITCHING') {
                            processPitchSelection(i);
                        }
                        return;
                    }
                    
                    break;
                }
            }
        }

        // ============= GAME LOOP =============
        function gameLoop() {
            if (game.mode === 'GAMEPLAY' && !game.animating) {
                drawGameScreen();
            }
            
            requestAnimationFrame(gameLoop);
        }

        // ============= INITIALIZE =============
        window.addEventListener('load', () => {
            showMainMenu();
            gameLoop();
        });

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            if (game.mode === 'MAIN_MENU') {
                drawMainMenu();
            } else if (game.mode === 'GAMEPLAY') {
                drawGameScreen();
                initializeFieldPlayers();
            } else if (game.mode === 'BATTING') {
                drawSwingMenu();
            } else if (game.mode === 'PITCHING') {
                drawPitchMenu();
            }
        });

        // ============= RUNNER ANIMATION FUNCTIONS =============
        function createAllRunnerPaths(outcome, currentBases) {
            if (!game.fieldCoords) return [];
            
            const coords = game.fieldCoords;
            const runners = [];
            
            if (outcome === 'Steal Second') {
                // Only the runner on first base moves
                if (currentBases.first) {
                    runners.push({
                        id: 'first-to-second',
                        color: currentBases.first === 'user' ? colors.playerRed : colors.playerBlue,
                        path: [coords.first, { x: coords.second.x + 20, y: coords.second.y - 20 }, coords.second]
                    });
                }
            } else if (outcome === 'Steal Third') {
                // Only the runner on second base moves
                if (currentBases.second) {
                    runners.push({
                        id: 'second-to-third',
                        color: currentBases.second === 'user' ? colors.playerRed : colors.playerBlue,
                        path: [coords.second, { x: coords.third.x + 20, y: coords.third.y + 20 }, coords.third]
                    });
                }
            } else if (outcome === 'Bunt Advance') {
                // Handle base runners advancing on bunt ground out (batter doesn't run)
                if (currentBases.second) {
                    runners.push({
                        id: 'second-to-third',
                        color: currentBases.second === 'user' ? colors.playerRed : colors.playerBlue,
                        path: [coords.second, { x: coords.third.x + 20, y: coords.third.y + 20 }, coords.third]
                    });
                }
                
                if (currentBases.first) {
                    runners.push({
                        id: 'first-to-second',
                        color: currentBases.first === 'user' ? colors.playerRed : colors.playerBlue,
                        path: [coords.first, { x: coords.second.x + 20, y: coords.second.y - 20 }, coords.second]
                    });
                }
            } else if (['Single', 'Double', 'Triple', 'Home Run'].includes(outcome)) {
                // Batter runs
                const batterPath = [{ x: coords.home.x - 40, y: coords.home.y }];
                const firstApproach = { x: coords.first.x - 20, y: coords.first.y + 20 };
                batterPath.push(firstApproach, coords.first);
                
                if (['Double', 'Triple', 'Home Run'].includes(outcome)) {
                    const secondApproach = { x: coords.second.x + 20, y: coords.second.y - 20 };
                    batterPath.push(secondApproach, coords.second);
                    
                    if (['Triple', 'Home Run'].includes(outcome)) {
                        const thirdApproach = { x: coords.third.x + 20, y: coords.third.y + 20 };
                        batterPath.push(thirdApproach, coords.third);
                        
                        if (outcome === 'Home Run') {
                            const homeApproach = { x: coords.home.x + 20, y: coords.home.y - 20 };
                            batterPath.push(homeApproach, coords.home);
                        }
                    }
                }
                
                runners.push({
                    id: 'batter',
                    color: colors.playerRed,
                    path: batterPath
                });
                
                // Existing runners advance
                if (currentBases.third) {
                    // Runner on third scores
                    runners.push({
                        id: 'third-to-home',
                        color: currentBases.third === 'user' ? colors.playerRed : colors.playerBlue,
                        path: [coords.third, { x: coords.home.x + 20, y: coords.home.y - 20 }, coords.home]
                    });
                }
                
                if (currentBases.second) {
                    if (outcome === 'Double' || outcome === 'Triple' || outcome === 'Home Run') {
                        // Runner scores from second
                        runners.push({
                            id: 'second-to-home',
                            color: currentBases.second === 'user' ? colors.playerRed : colors.playerBlue,
                            path: [coords.second, { x: coords.third.x + 20, y: coords.third.y + 20 }, coords.third, { x: coords.home.x + 20, y: coords.home.y - 20 }, coords.home]
                        });
                    } else {
                        // Runner advances to third
                        runners.push({
                            id: 'second-to-third',
                            color: currentBases.second === 'user' ? colors.playerRed : colors.playerBlue,
                            path: [coords.second, { x: coords.third.x + 20, y: coords.third.y + 20 }, coords.third]
                        });
                    }
                }
                
                if (currentBases.first) {
                    if (outcome === 'Triple' || outcome === 'Home Run') {
                        // Runner scores from first
                        runners.push({
                            id: 'first-to-home',
                            color: currentBases.first === 'user' ? colors.playerRed : colors.playerBlue,
                            path: [coords.first, { x: coords.second.x + 20, y: coords.second.y - 20 }, coords.second, { x: coords.third.x + 20, y: coords.third.y + 20 }, coords.third, { x: coords.home.x + 20, y: coords.home.y - 20 }, coords.home]
                        });
                    } else if (outcome === 'Double') {
                        // Runner advances to third
                        runners.push({
                            id: 'first-to-third',
                            color: currentBases.first === 'user' ? colors.playerRed : colors.playerBlue,
                            path: [coords.first, { x: coords.second.x + 20, y: coords.second.y - 20 }, coords.second, { x: coords.third.x + 20, y: coords.third.y + 20 }, coords.third]
                        });
                    } else {
                        // Runner advances to second
                        runners.push({
                            id: 'first-to-second',
                            color: currentBases.first === 'user' ? colors.playerRed : colors.playerBlue,
                            path: [coords.first, { x: coords.second.x + 20, y: coords.second.y - 20 }, coords.second]
                        });
                    }
                }
            }
            
            return runners;
        }

        function startRunnerAnimation(outcome, callback) {
            // Store current base state before updating
            const currentBases = { ...game.bases };
            const runnerData = createAllRunnerPaths(outcome, currentBases);
            
            if (runnerData.length === 0) {
                if (callback) callback();
                return;
            }
            
            // Initialize all runners
            game.runnerAnimation.active = true;
            game.runnerAnimation.runners = runnerData.map(data => ({
                id: data.id,
                player: new Player(data.path[0].x, data.path[0].y, data.color, 'RUN'),
                path: data.path,
                pathIndex: 0,
                progress: 0,
                speed: 0.008,
                pauseTime: 0,
                pauseDuration: 600,
                completed: false
            }));
            
            game.runnerAnimation.completedAnimations = 0;
            game.runnerAnimation.totalAnimations = game.runnerAnimation.runners.length;
            game.animating = true;
            
            function animateAllRunners() {
                if (!game.runnerAnimation.active) {
                    game.animating = false;
                    // Apply base updates after animation completes
                    if (game.pendingBaseUpdate) {
                        game.pendingBaseUpdate();
                        game.pendingBaseUpdate = null;
                    }
                    if (callback) callback();
                    return;
                }
                
                const currentTime = Date.now();
                let allCompleted = true;
                
                game.runnerAnimation.runners.forEach(runner => {
                    if (runner.completed) return;
                    
                    // Check if we're in a pause at a base
                    if (runner.pauseTime > 0) {
                        if (currentTime - runner.pauseTime < runner.pauseDuration) {
                            allCompleted = false;
                            return;
                        } else {
                            runner.pauseTime = 0;
                            runner.pathIndex++;
                            runner.progress = 0;
                        }
                    }
                    
                    // Check if this runner's animation is complete
                    if (runner.pathIndex >= runner.path.length - 1) {
                        runner.completed = true;
                        game.runnerAnimation.completedAnimations++;
                        return;
                    }
                    
                    allCompleted = false;
                    
                    // Animate between current and next point
                    const from = runner.path[runner.pathIndex];
                    const to = runner.path[runner.pathIndex + 1];
                    
                    // Apply easing function
                    const easedProgress = easeInOutQuad(runner.progress);
                    
                    // Update runner position
                    runner.player.x = from.x + (to.x - from.x) * easedProgress;
                    runner.player.y = from.y + (to.y - from.y) * easedProgress;
                    
                    // Increase progress
                    runner.progress += runner.speed;
                    
                    // Check if we've reached the next point
                    if (runner.progress >= 1) {
                        runner.player.x = to.x;
                        runner.player.y = to.y;
                        
                        // Check if this is a base (pause point)
                        const coords = game.fieldCoords;
                        const isBase = (
                            (Math.abs(to.x - coords.first.x) < 5 && Math.abs(to.y - coords.first.y) < 5) ||
                            (Math.abs(to.x - coords.second.x) < 5 && Math.abs(to.y - coords.second.y) < 5) ||
                            (Math.abs(to.x - coords.third.x) < 5 && Math.abs(to.y - coords.third.y) < 5) ||
                            (Math.abs(to.x - coords.home.x) < 5 && Math.abs(to.y - coords.home.y) < 5)
                        );
                        
                        if (isBase && runner.pathIndex < runner.path.length - 2) {
                            // Pause at base
                            runner.pauseTime = currentTime;
                        } else {
                            // Continue to next segment
                            runner.pathIndex++;
                            runner.progress = 0;
                        }
                    }
                });
                
                if (allCompleted) {
                    game.runnerAnimation.active = false;
                    game.animating = false;
                    // Apply base updates after animation completes
                    if (game.pendingBaseUpdate) {
                        game.pendingBaseUpdate();
                        game.pendingBaseUpdate = null;
                    }
                    if (callback) callback();
                } else {
                    drawGameScreen();
                    drawAllRunningPlayers();
                    requestAnimationFrame(animateAllRunners);
                }
            }
            
            animateAllRunners();
        }

        function drawAllRunningPlayers() {
            if (game.runnerAnimation.active) {
                game.runnerAnimation.runners.forEach(runner => {
                    if (!runner.completed) {
                        // Add running motion effect
                        runner.player.animation += 0.2;
                        runner.player.draw();
                        
                        // Add dust trail effect
                        ctx.fillStyle = 'rgba(139, 105, 20, 0.3)';
                        for (let i = 0; i < 3; i++) {
                            const trailX = runner.player.x - (i + 1) * 8;
                            const trailY = runner.player.y + 8 + Math.random() * 4;
                            ctx.beginPath();
                            ctx.arc(trailX, trailY, 2 - i * 0.5, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                });
            }
        }

        function easeInOutQuad(t) {
            return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
        }

        // ============= BALL FLIGHT AND THROW ANIMATION FUNCTIONS =============
        function getFielderPosition(outcome) {
            if (!game.fieldCoords || !fieldPlayers) return null;
            
            // Find appropriate fielder based on outcome type
            let targetPlayer = null;
            
            if (outcome === 'Pop Fly Out') {
                // Random outfielder for pop fly
                const outfielders = fieldPlayers.filter(p => ['LF', 'CF', 'RF'].includes(p.position));
                targetPlayer = outfielders[Math.floor(Math.random() * outfielders.length)];
            } else if (outcome === 'Ground Out') {
                // Infielders for ground out
                const infielders = fieldPlayers.filter(p => ['1B', '2B', 'SS', '3B'].includes(p.position));
                targetPlayer = infielders[Math.floor(Math.random() * infielders.length)];
            } else if (outcome === 'Single') {
                // Land in infield gaps between players
                const coords = game.fieldCoords;
                const size = game.diamondSize;
                const gapOptions = [
                    // Gap between 1B and 2B
                    { x: coords.first.x + size * 0.15, y: coords.first.y + size * 0.15 },
                    // Gap between SS and 3B
                    { x: coords.third.x + size * 0.15, y: coords.third.y + size * 0.15 },
                    // Gap between 2B and SS (up the middle)
                    { x: coords.second.x, y: coords.second.y + size * 0.3 },
                    // Shallow outfield between infield and outfield
                    { x: coords.first.x + size * 0.2, y: coords.first.y - size * 0.1 },
                    { x: coords.third.x - size * 0.2, y: coords.third.y - size * 0.1 }
                ];
                return gapOptions[Math.floor(Math.random() * gapOptions.length)];
            } else if (outcome === 'Double') {
                // Deep outfield gaps between outfielders
                const coords = game.fieldCoords;
                const size = game.diamondSize;
                const gapOptions = [
                    // Gap between LF and CF
                    { x: coords.third.x - size * 0.35, y: coords.second.y - size * 0.45 },
                    // Gap between CF and RF
                    { x: coords.first.x + size * 0.35, y: coords.second.y - size * 0.45 },
                    // Deep center field
                    { x: coords.second.x, y: coords.second.y - size * 0.7 },
                    // Down the foul lines (fair territory)
                    { x: coords.first.x + size * 0.5, y: coords.first.y - size * 0.3 },
                    { x: coords.third.x - size * 0.5, y: coords.third.y - size * 0.3 }
                ];
                return gapOptions[Math.floor(Math.random() * gapOptions.length)];
            } else if (outcome === 'Triple') {
                // Very deep outfield corners and gaps
                const coords = game.fieldCoords;
                const size = game.diamondSize;
                const gapOptions = [
                    // Deep left field corner
                    { x: coords.third.x - size * 0.8, y: coords.second.y - size * 0.6 },
                    // Deep right field corner
                    { x: coords.first.x + size * 0.8, y: coords.second.y - size * 0.6 },
                    // Deep center field gap
                    { x: coords.second.x + (Math.random() - 0.5) * size * 0.3, y: coords.second.y - size * 0.8 }
                ];
                return gapOptions[Math.floor(Math.random() * gapOptions.length)];
            } else if (outcome === 'Home Run') {
                // Over the fence
                return {
                    x: canvas.width / 2 + (Math.random() - 0.5) * 200,
                    y: 50,
                    player: null
                };
            } else if (outcome === 'Foul') {
                // Foul territory
                const coords = game.fieldCoords;
                const isLeft = Math.random() < 0.5;
                return {
                    x: isLeft ? 100 : canvas.width - 100,
                    y: canvas.height - 100,
                    player: null
                };
            }
            
            return targetPlayer ? { x: targetPlayer.x, y: targetPlayer.y, player: targetPlayer } : null;
        }

        function drawBallFlightAndThrow(from, outcome, callback) {
            const targetInfo = getFielderPosition(outcome);
            if (!targetInfo) {
                if (callback) callback();
                return;
            }
            
            const to = { x: targetInfo.x, y: targetInfo.y };
            const fielder = targetInfo.player;
            
            // First phase: Ball flight to target
            drawBallArc(from, to, 1200, () => {
                // Second phase: If it's an out and there's a fielder, throw back to pitcher
                if (['Pop Fly Out', 'Ground Out'].includes(outcome) && fielder) {
                    const pitcherPos = game.fieldCoords.pitcher;
                    setTimeout(() => {
                        drawBallArc(to, pitcherPos, 800, callback);
                    }, 300); // Brief pause for catch
                } else {
                    if (callback) callback();
                }
            });
        }

        function drawBallArc(from, to, duration, callback) {
            const startTime = Date.now();
            const ballSize = 8;
            const distance = Math.sqrt((to.x - from.x) ** 2 + (to.y - from.y) ** 2);
            const arcHeight = Math.min(150, distance * 0.3); // Dynamic arc height based on distance

            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Calculate ball position with realistic arc
                const currentX = from.x + (to.x - from.x) * progress;
                const baseY = from.y + (to.y - from.y) * progress;
                const arcOffset = Math.sin(progress * Math.PI) * arcHeight;
                const currentY = baseY - arcOffset;

                drawGameScreen();
                
                // Draw ball shadow on ground
                const shadowY = from.y + (to.y - from.y) * progress;
                const shadowSize = ballSize * (1 - arcOffset / (arcHeight + 50));
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.ellipse(currentX, shadowY + 10, shadowSize, shadowSize * 0.5, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw ball trail with perspective
                for (let i = 0; i < 5; i++) {
                    const trailProgress = Math.max(0, progress - i * 0.03);
                    const trailX = from.x + (to.x - from.x) * trailProgress;
                    const trailBaseY = from.y + (to.y - from.y) * trailProgress;
                    const trailArcOffset = Math.sin(trailProgress * Math.PI) * arcHeight;
                    const trailY = trailBaseY - trailArcOffset;
                    
                    const alpha = 0.4 - i * 0.08;
                    const size = ballSize - i * 1.5;
                    
                    ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                    ctx.shadowColor = 'rgba(255, 255, 255, 0.3)';
                    ctx.shadowBlur = 8;
                    ctx.beginPath();
                    ctx.arc(trailX, trailY, Math.max(1, size), 0, Math.PI * 2);
                    ctx.fill();
                }

                // Draw main ball with enhanced effects
                ctx.shadowColor = colors.ballWhite;
                ctx.shadowBlur = 15;
                ctx.fillStyle = colors.ballWhite;
                ctx.beginPath();
                ctx.arc(currentX, currentY, ballSize, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                
                // Add baseball seams
                ctx.strokeStyle = '#cccccc';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(currentX, currentY, ballSize * 0.7, 0, Math.PI);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(currentX, currentY, ballSize * 0.7, Math.PI, Math.PI * 2);
                ctx.stroke();

                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    if (callback) callback();
                }
            }

            animate();
        }
    </script>
</body>
</html>
