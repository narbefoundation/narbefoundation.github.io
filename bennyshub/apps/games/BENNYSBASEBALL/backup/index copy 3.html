<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Benny's Baseball Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #000428 0%, #004e92 100%);
            overflow: hidden;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }

        #gameCanvas {
            display: block;
            background: #1a5f1a;
            margin: 0 auto;
            cursor: pointer;
        }

        .controls-info {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            font-size: 14px;
            text-align: center;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px 16px;
            border-radius: 8px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            max-width: 90vw;
            word-wrap: break-word;
            z-index: 100;
        }

        @media (max-width: 768px) {
            .controls-info {
                font-size: 12px;
                padding: 6px 12px;
                bottom: 5px;
            }
            
            #pauseButton {
                font-size: 14px;
                padding: 8px 16px;
                bottom: 15px;
                left: 15px;
            }
        }

        @media (max-width: 480px) {
            .controls-info {
                font-size: 10px;
                padding: 4px 8px;
                border-radius: 6px;
                bottom: 3px;
            }
            
            #pauseButton {
                font-size: 12px;
                padding: 6px 12px;
                bottom: 10px;
                left: 10px;
            }
        }

        #pauseButton {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: linear-gradient(135deg, rgba(20, 48, 30, 0.95) 0%, rgba(10, 30, 15, 0.95) 100%);
            color: #4aff9e;
            border: 3px solid #4aff9e;
            padding: 12px 24px;
            font-size: 16px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            z-index: 1000;
            display: none;
        }

        #pauseButton:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(74, 255, 158, 0.4);
            background: linear-gradient(135deg, rgba(30, 58, 40, 0.95) 0%, rgba(20, 40, 25, 0.95) 100%);
        }

        #pauseButton:active {
            transform: translateY(0px);
        }

        #pauseButton.visible {
            display: block;
        }

        .pause-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 999;
        }

        .pause-overlay.active {
            display: flex;
        }

        .pause-menu {
            background: linear-gradient(135deg, rgba(20, 48, 30, 0.95) 0%, rgba(10, 30, 15, 0.95) 100%);
            border: 3px solid #4aff9e;
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            color: #fff;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }

        .pause-menu h2 {
            font-size: 48px;
            margin-bottom: 30px;
            color: #4aff9e;
            text-shadow: 3px 3px 0px rgba(0, 0, 0, 0.3);
        }

        .pause-menu button {
            display: block;
            width: 100%;
            padding: 15px 30px;
            margin: 15px 0;
            font-size: 24px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            background: linear-gradient(135deg, rgba(255, 235, 59, 0.2) 0%, rgba(255, 235, 59, 0.4) 50%, rgba(255, 235, 59, 0.2) 100%);
            border: 2px solid #ffeb3b;
            color: #ffeb3b;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .pause-menu button:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(255, 235, 59, 0.4);
            background: linear-gradient(135deg, rgba(255, 235, 59, 0.3) 0%, rgba(255, 235, 59, 0.5) 50%, rgba(255, 235, 59, 0.3) 100%);
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <button id="pauseButton">⏸ PAUSE</button>
    <div class="controls-info">
        SPACE: Scan Options | ENTER: Select | CLICK: Select Option
    </div>

    <!-- Pause Menu Overlay -->
    <div class="pause-overlay" id="pauseOverlay">
        <div class="pause-menu" id="pauseMenu">
            <h2>⏸ PAUSED</h2>
            <button onclick="resumeGame()">Resume Game</button>
            <button onclick="showPauseSettings()">Settings</button>
            <button onclick="restartGame()">Restart Game</button>
            <button onclick="quitToMenu()">Main Menu</button>
        </div>
        
        <!-- Pause Settings Menu -->
        <div class="pause-menu" id="pauseSettingsMenu" style="display: none;">
            <h2>⚙️ SETTINGS</h2>
            <button id="pauseMusicToggle" onclick="togglePauseMusic()">Music: ON</button>
            <button id="pauseSoundToggle" onclick="togglePauseSound()">Sound Effects: ON</button>
            <button id="pauseTTSToggle" onclick="togglePauseTTS()">Text-to-Speech: ON</button>
            <button id="pauseVoiceToggle" onclick="togglePauseVoice()">Voice: DEFAULT</button>
            <button onclick="pauseNextTrack()">Next Track</button>
            <button onclick="pauseResetSeason()">Reset Season</button>
            <button onclick="backToPauseMenu()">Back</button>
        </div>
    </div>

    <!-- Sound Effects -->
    <audio id="scanSound" src="data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQAAAAA="></audio>
    <audio id="selectSound" src="data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQAAAAA="></audio>
    <audio id="hitSound"></audio>
    <audio id="homerunSound"></audio>
    <audio id="bgMusic" loop></audio>

    <script>
        // ============= GAME CONSTANTS =============
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const pauseButton = document.getElementById('pauseButton');
        const pauseOverlay = document.getElementById('pauseOverlay');
        
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // ============= AUDIO SYSTEM =============
        const audioSystem = {
            musicEnabled: true,
            soundEnabled: true,
            ttsEnabled: true,
            voiceType: 'default', // 'default', 'male', 'female'
            currentTrack: 0,
            tracks: [
                'audio/music/music (1).mp3',
                'audio/music/music (2).mp3',
                'audio/music/music (3).mp3',
                'audio/music/music (4).mp3'
            ],
            currentAudio: null
        };

        // ============= COLOR SYSTEM =============
        const colorOptions = [
            { name: 'Red', color: '#ff0000', light: '#ff4444' },
            { name: 'Blue', color: '#0066ff', light: '#4488ff' },
            { name: 'Green', color: '#00cc00', light: '#44dd44' },
            { name: 'Yellow', color: '#ffcc00', light: '#ffdd44' },
            { name: 'Purple', color: '#8800cc', light: '#aa44dd' },
            { name: 'Orange', color: '#ff6600', light: '#ff8844' },
            { name: 'Pink', color: '#ff0088', light: '#ff44aa' },
            { name: 'White', color: '#ffffff', light: '#cccccc' },
            { name: 'Black', color: '#000000', light: '#444444' }
        ];

        // ============= SEASON SYSTEM =============
        const seasonData = {
            wins: 0,
            losses: 0,
            active: false,
            teamColor: null,
            playedTeams: [],
            inPlayoffs: false,
            inChampionship: false
        };

        // ============= GAME STATE =============
        const game = {
            mode: 'MAIN_MENU',
            previousMode: null,
            currentInning: 1,
            half: 'top',
            outs: 0,
            score: { Blue: 0, Red: 0 },
            bases: { first: null, second: null, third: null },
            balls: 0,
            strikes: 0,
            homeTeam: 'Blue',
            awayTeam: 'Red',
            selectedIndex: 0,
            menuOptions: [],
            menuBounds: [],
            colorGrid: [], // For color selection
            firstPitch: true,
            selectedPitch: null,
            selectedPitchLocation: null,
            selectedSwing: null,
            samePitchCount: 0,
            lastPitchType: null,
            spaceHeld: false,
            spaceHoldStart: 0,
            lastSpaceScan: 0,
            returnHeld: false,
            returnHoldStart: 0,
            animating: false,
            speech: window.speechSynthesis,
            ballAnimation: null,
            runnerAnimation: {
                active: false,
                runners: [],
                completedAnimations: 0,
                totalAnimations: 0
            },
            lastActionTime: 0,
            actionCooldown: 500,
            menuReady: false,
            hasScanned: false,
            pendingBaseUpdate: null,
            playInProgress: false,
            inputsBlocked: false,
            playCompleteCooldown: 1500,
            transitionText: '',
            recommendedPitch: null,
            recommendedPitchTimer: 0
        };

        // ============= SEASON MANAGEMENT =============
        function initializeSeasonData() {
            const saved = localStorage.getItem('bennyBaseball_season');
            if (saved) {
                Object.assign(seasonData, JSON.parse(saved));
            }
        }

        function saveSeasonData() {
            localStorage.setItem('bennyBaseball_season', JSON.stringify(seasonData));
        }

        function resetSeason() {
            seasonData.wins = 0;
            seasonData.losses = 0;
            seasonData.active = false;
            seasonData.teamColor = null;
            seasonData.playedTeams = [];
            seasonData.inPlayoffs = false;
            seasonData.inChampionship = false;
            saveSeasonData();
        }

        function updateSeasonProgress(won) {
            if (!seasonData.active) return;
            
            if (won) {
                seasonData.wins++;
            } else {
                seasonData.losses++;
            }
            
            // Check for playoff/championship eligibility
            const totalGames = seasonData.wins + seasonData.losses;
            
            if (seasonData.wins >= 8) {
                // Perfect season - straight to championship
                seasonData.inChampionship = true;
            } else if (seasonData.wins >= 6 && totalGames >= 8) {
                // Qualified for playoffs
                seasonData.inPlayoffs = true;
            } else if (totalGames >= 8 && seasonData.wins < 6) {
                // Failed to qualify - reset season
                resetSeason();
                speak("Season over. You didn't qualify for playoffs.");
                return;
            }
            
            saveSeasonData();
        }

        function getAvailableOpponents() {
            return colorOptions.filter(color => 
                color.name !== seasonData.teamColor && 
                !seasonData.playedTeams.includes(color.name)
            );
        }

        function selectOpponentColor() {
            let available;
            
            if (seasonData.inPlayoffs || seasonData.inChampionship) {
                // Playoffs/Championship can be any color except player's
                available = colorOptions.filter(color => color.name !== seasonData.teamColor);
            } else {
                // Regular season - no repeats
                available = getAvailableOpponents();
            }
            
            if (available.length === 0) {
                // Fallback - just not player color
                available = colorOptions.filter(color => color.name !== seasonData.teamColor);
            }
            
            const opponent = available[Math.floor(Math.random() * available.length)];
            
            if (!seasonData.inPlayoffs && !seasonData.inChampionship) {
                seasonData.playedTeams.push(opponent.name);
            }
            
            return opponent;
        }

        // ============= AUDIO FUNCTIONS =============
        function initializeAudioSettings() {
            const saved = localStorage.getItem('bennyBaseball_audio');
            if (saved) {
                Object.assign(audioSystem, JSON.parse(saved));
            }
        }

        function saveAudioSettings() {
            localStorage.setItem('bennyBaseball_audio', JSON.stringify(audioSystem));
        }

        function speak(text) {
            if (!audioSystem.ttsEnabled || !game.speech) return;
            
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.rate = 1.0;
            utterance.pitch = 1.0;
            
            // Apply voice type preference
            const voices = game.speech.getVoices();
            if (voices.length > 0) {
                if (audioSystem.voiceType === 'male') {
                    const maleVoice = voices.find(voice => 
                        voice.name.toLowerCase().includes('male') || 
                        voice.name.toLowerCase().includes('david') ||
                        voice.name.toLowerCase().includes('mark')
                    );
                    if (maleVoice) utterance.voice = maleVoice;
                } else if (audioSystem.voiceType === 'female') {
                    const femaleVoice = voices.find(voice => 
                        voice.name.toLowerCase().includes('female') || 
                        voice.name.toLowerCase().includes('zira') ||
                        voice.name.toLowerCase().includes('susan')
                    );
                    if (femaleVoice) utterance.voice = femaleVoice;
                }
            }
            
            game.speech.cancel();
            game.speech.speak(utterance);
        }

        function playBackgroundMusic() {
            if (!audioSystem.musicEnabled || audioSystem.tracks.length === 0) return;
            
            if (audioSystem.currentAudio) {
                audioSystem.currentAudio.pause();
                audioSystem.currentAudio.currentTime = 0;
                audioSystem.currentAudio = null;
            }
            
            // Try to play the current track (will fallback to generated if file doesn't exist)
            audioSystem.currentAudio = new Audio(audioSystem.tracks[audioSystem.currentTrack]);
            audioSystem.currentAudio.loop = true;
            audioSystem.currentAudio.volume = 0.15; // 15% volume
            
            // Handle both successful play and errors
            const playPromise = audioSystem.currentAudio.play();
            
            if (playPromise !== undefined) {
                playPromise.then(() => {
                    // Music started successfully
                    console.log('Music started successfully');
                }).catch((error) => {
                    // Auto-play was prevented, will try generated music
                    console.log('Audio play prevented, trying generated music:', error);
                    playGeneratedMusic();
                });
            } else {
                // Older browser fallback
                setTimeout(() => {
                    if (audioSystem.currentAudio.paused) {
                        playGeneratedMusic();
                    }
                }, 100);
            }
        }

        // Add a function to enable audio after first user interaction
        let audioUnlocked = false;
        
        function unlockAudio() {
            if (audioUnlocked) return;
            
            // Create a silent audio context to unlock audio
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const source = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            source.connect(gainNode);
            gainNode.connect(audioContext.destination);
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            source.start(audioContext.currentTime);
            source.stop(audioContext.currentTime + 0.1);
            
            audioUnlocked = true;
            
            // Try to start music if enabled
            if (audioSystem.musicEnabled && game.mode === 'MAIN_MENU') {
                playBackgroundMusic();
            }
        }

        function playGeneratedMusic() {
            // Simple generated background music using Web Audio API
            const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(220, audioCtx.currentTime);
            gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
            
            oscillator.start();
            
            setTimeout(() => {
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 1);
                oscillator.stop(audioCtx.currentTime + 1);
            }, 30000); // 30 second loop
        }

        function nextTrack() {
            audioSystem.currentTrack = (audioSystem.currentTrack + 1) % audioSystem.tracks.length;
            playBackgroundMusic();
        }

        function stopMusic() {
            if (audioSystem.currentAudio) {
                audioSystem.currentAudio.pause();
                audioSystem.currentAudio = null;
            }
        }

        function playSound(type) {
            if (!audioSystem.soundEnabled) return;
            
            const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            
            if (type === 'scan') {
                oscillator.frequency.value = 440;
                gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                oscillator.start(audioCtx.currentTime);
                oscillator.stop(audioCtx.currentTime + 0.1);
            } else if (type === 'select') {
                oscillator.frequency.value = 880;
                gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
                oscillator.start(audioCtx.currentTime);
                oscillator.stop(audioCtx.currentTime + 0.15);
            } else if (type === 'hit') {
                oscillator.frequency.value = 200;
                gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
                oscillator.start(audioCtx.currentTime);
                oscillator.stop(audioCtx.currentTime + 0.3);
            } else if (type === 'cheer') {
                // Multiple frequency cheer sound
                for (let i = 0; i < 3; i++) {
                    setTimeout(() => {
                        const cheer = audioCtx.createOscillator();
                        const cheerGain = audioCtx.createGain();
                        cheer.connect(cheerGain);
                        cheerGain.connect(audioCtx.destination);
                        cheer.frequency.value = 600 + Math.random() * 400;
                        cheerGain.gain.setValueAtTime(0.15, audioCtx.currentTime);
                        cheerGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
                        cheer.start(audioCtx.currentTime);
                        cheer.stop(audioCtx.currentTime + 0.2);
                    }, i * 100);
                }
            }
        }

        // ============= PLAYER POSITIONS =============
        class Player {
            constructor(x, y, color, position) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.position = position;
                this.size = 20;
                this.animation = 0;
            }

            draw() {
                ctx.save();
                
                // Draw shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.ellipse(this.x, this.y + 12, 8, 4, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw player as retro pixel character
                ctx.fillStyle = this.color;
                
                // Head
                ctx.fillRect(this.x - 4, this.y - 16, 8, 8);
                
                // Body
                ctx.fillRect(this.x - 6, this.y - 8, 12, 10);
                
                // Arms (animated)
                const armOffset = Math.sin(this.animation) * 2;
                ctx.fillRect(this.x - 10, this.y - 6 + armOffset, 4, 8);
                ctx.fillRect(this.x + 6, this.y - 6 - armOffset, 4, 8);
                
                // Legs
                ctx.fillRect(this.x - 6, this.y + 2, 4, 8);
                ctx.fillRect(this.x + 2, this.y + 2, 4, 8);
                
                // Add number on jersey with better contrast
                ctx.fillStyle = '#000000';
                ctx.fillRect(this.x - 3, this.y - 5, 6, 6);
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 7px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(this.position, this.x, this.y - 1);
                
                this.animation += 0.05;
                ctx.restore();
            }
        }

        let fieldPlayers = [];

        // ============= DRAWING FUNCTIONS =============
        function drawField() {
            const cx = canvas.width / 2;
            const cy = canvas.height / 2 + 50;
            const diamondSize = Math.min(canvas.width, canvas.height) * 0.35;

            // Draw outfield with gradient
            const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, diamondSize * 2);
            gradient.addColorStop(0, colors.grassLight);
            gradient.addColorStop(1, colors.grass);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw infield dirt with gradient
            ctx.save();
            ctx.translate(cx, cy);
            ctx.rotate(Math.PI / 4);
            const dirtGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, diamondSize);
            dirtGradient.addColorStop(0, colors.dirtLight);
            dirtGradient.addColorStop(1, colors.dirt);
            ctx.fillStyle = dirtGradient;
            ctx.fillRect(-diamondSize * 0.7, -diamondSize * 0.7, diamondSize * 1.4, diamondSize * 1.4);
            ctx.restore();

            // Draw diamond lines with glow effect
            ctx.shadowColor = 'rgba(255, 255, 255, 0.5)';
            ctx.shadowBlur = 10;
            ctx.strokeStyle = colors.baseLine;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(cx, cy + diamondSize / 2);
            ctx.lineTo(cx + diamondSize / 2, cy);
            ctx.lineTo(cx, cy - diamondSize / 2);
            ctx.lineTo(cx - diamondSize / 2, cy);
            ctx.closePath();
            ctx.stroke();

            // Foul lines
            ctx.beginPath();
            ctx.moveTo(cx, cy + diamondSize / 2);
            ctx.lineTo(cx + diamondSize, cy + diamondSize);
            ctx.moveTo(cx, cy + diamondSize / 2);
            ctx.lineTo(cx - diamondSize, cy + diamondSize);
            ctx.stroke();
            ctx.shadowBlur = 0;

            // Draw pitcher's mound with 3D effect
            const moundRadius = diamondSize * 0.12;
            const moundGradient = ctx.createRadialGradient(cx, cy - 5, 0, cx, cy, moundRadius);
            moundGradient.addColorStop(0, colors.dirtLight);
            moundGradient.addColorStop(1, colors.dirt);
            ctx.fillStyle = moundGradient;
            ctx.beginPath();
            ctx.arc(cx, cy, moundRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Draw bases
            drawBases(cx, cy, diamondSize);

            // Store field coordinates
            game.fieldCoords = {
                home: { x: cx, y: cy + diamondSize / 2 },
                first: { x: cx + diamondSize / 2, y: cy },
                second: { x: cx, y: cy - diamondSize / 2 },
                third: { x: cx - diamondSize / 2, y: cy },
                pitcher: { x: cx, y: cy }
            };
            game.diamondSize = diamondSize;
        }

        function drawBases(cx, cy, diamondSize) {
            const baseSize = diamondSize * 0.08;
            const bases = [
                { name: 'home', x: cx, y: cy + diamondSize / 2 },
                { name: 'first', x: cx + diamondSize / 2, y: cy },
                { name: 'second', x: cx, y: cy - diamondSize / 2 },
                { name: 'third', x: cx - diamondSize / 2, y: cy }
            ];

            bases.forEach(base => {
                let fillColor = '#ffffff';
                
                if (base.name !== 'home') {
                    const runner = game.bases[base.name];
                    if (runner === 'user') fillColor = colors.playerRed;
                    else if (runner === 'comp') fillColor = colors.playerBlue;
                }

                // Add glow effect for occupied bases
                if (fillColor !== '#ffffff') {
                    ctx.shadowColor = fillColor;
                    ctx.shadowBlur = 15;
                }

                ctx.fillStyle = fillColor;
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;

                if (base.name === 'home') {
                    ctx.beginPath();
                    ctx.moveTo(base.x, base.y - baseSize);
                    ctx.lineTo(base.x + baseSize / 2, base.y - baseSize / 2);
                    ctx.lineTo(base.x + baseSize / 2, base.y + baseSize / 2);
                    ctx.lineTo(base.x - baseSize / 2, base.y + baseSize / 2);
                    ctx.lineTo(base.x - baseSize / 2, base.y - baseSize / 2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                } else {
                    ctx.save();
                    ctx.translate(base.x, base.y);
                    ctx.rotate(Math.PI / 4);
                    ctx.fillRect(-baseSize / 2, -baseSize / 2, baseSize, baseSize);
                    ctx.strokeRect(-baseSize / 2, -baseSize / 2, baseSize, baseSize);
                    ctx.restore();
                }
                
                ctx.shadowBlur = 0;
            });
        }

        function drawScoreboard() {
            const padding = 20;
            const fontSize = 24;
            
            ctx.font = `bold ${fontSize}px monospace`;
            ctx.textAlign = 'center';
            ctx.fillStyle = '#ffffff';
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 3;

            // Inning and Outs at top with background
            const topText = `INNING: ${game.half.toUpperCase()} ${game.currentInning}       OUTS: ${game.outs}/3`;
            const topWidth = ctx.measureText(topText).width + 40;
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(canvas.width / 2 - topWidth / 2, 15, topWidth, 40);
            
            ctx.fillStyle = '#ffffff';
            ctx.strokeText(topText, canvas.width / 2, 40);
            ctx.fillText(topText, canvas.width / 2, 40);

            // Score display - Clean style with translucent backgrounds
            const scoreSize = 120;
            ctx.font = `bold ${scoreSize}px monospace`;
            
            // Player score (Red) on left
            const leftScoreBg = { x: canvas.width * 0.2 - 100, y: 50, width: 200, height: 140 };
            
            // Translucent gray background
            ctx.fillStyle = 'rgba(128, 128, 128, 0.7)';
            ctx.fillRect(leftScoreBg.x, leftScoreBg.y, leftScoreBg.width, leftScoreBg.height);
            
            // Score number in team color
            const leftScore = game.score.Red.toString();
            const leftScoreX = canvas.width * 0.2;
            const leftScoreY = 150;
            
            ctx.fillStyle = colors.playerRed;
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 3;
            ctx.strokeText(leftScore, leftScoreX, leftScoreY);
            ctx.fillText(leftScore, leftScoreX, leftScoreY);
            
            // Computer score (Blue) on right
            const rightScoreBg = { x: canvas.width * 0.8 - 100, y: 50, width: 200, height: 140 };
            
            // Translucent gray background
            ctx.fillStyle = 'rgba(128, 128, 128, 0.7)';
            ctx.fillRect(rightScoreBg.x, rightScoreBg.y, rightScoreBg.width, rightScoreBg.height);
            
            // Score number in team color
            const rightScore = game.score.Blue.toString();
            const rightScoreX = canvas.width * 0.8;
            const rightScoreY = 150;
            
            ctx.fillStyle = colors.playerBlue;
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 3;
            ctx.strokeText(rightScore, rightScoreX, rightScoreY);
            ctx.fillText(rightScore, rightScoreX, rightScoreY);

            // Visual Count Display - Strikes and Balls
            if (game.mode === 'BATTING' || game.mode === 'PITCHING') {
                drawCountIndicators();
            }
        }

        function drawCountIndicators() {
            const countX = canvas.width - 120;
            const countY = canvas.height - 140;
            const indicatorSize = 16;
            const spacing = 12;
            
            // Background panel for count - adjusted for horizontal layout
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(countX - 60, countY - 20, 120, 80);
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.strokeRect(countX - 60, countY - 20, 120, 80);
            
            // Strikes label
            ctx.font = 'bold 12px monospace';
            ctx.fillStyle = '#ffffff';
            ctx.textAlign = 'center';
            ctx.fillText('STRIKES', countX, countY - 5);
            
            // Draw 3 diamond-shaped strike indicators (horizontally)
            const activeStrikeColor = '#ff4444';
            const inactiveStrikeColor = 'rgba(255, 68, 68, 0.2)';
            
            for (let i = 0; i < 3; i++) {
                const strikeX = countX - 24 + i * (indicatorSize + spacing);
                const strikeY = countY + 15;
                const isActive = i < game.strikes;
                
                ctx.fillStyle = isActive ? activeStrikeColor : inactiveStrikeColor;
                ctx.strokeStyle = isActive ? '#ff0000' : '#666666';
                ctx.lineWidth = 1;
                
                // Draw diamond shape
                ctx.beginPath();
                ctx.moveTo(strikeX, strikeY - indicatorSize / 2);
                ctx.lineTo(strikeX + indicatorSize / 2, strikeY);
                ctx.lineTo(strikeX, strikeY + indicatorSize / 2);
                ctx.lineTo(strikeX - indicatorSize / 2, strikeY);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                // Add glow effect for active strikes
                if (isActive) {
                    ctx.shadowColor = activeStrikeColor;
                    ctx.shadowBlur = 8;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
            }
            
            // Balls label
            const ballsStartY = countY + 40;
            ctx.fillStyle = '#ffffff';
            ctx.fillText('BALLS', countX, ballsStartY - 5);
            
            // Draw 4 circular ball indicators (horizontally)
            const activeBallColor = '#ffffff';
            const inactiveBallColor = 'rgba(255, 255, 255, 0.2)';
            
            for (let i = 0; i < 4; i++) {
                const ballX = countX - 36 + i * (indicatorSize + spacing);
                const ballY = ballsStartY + 10;
                const isActive = i < game.balls;
                
                ctx.fillStyle = isActive ? activeBallColor : inactiveBallColor;
                ctx.strokeStyle = isActive ? '#cccccc' : '#666666';
                ctx.lineWidth = 1;
                
                // Draw circle
                ctx.beginPath();
                ctx.arc(ballX, ballY, indicatorSize / 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                
                // Add glow effect for active balls
                if (isActive) {
                    ctx.shadowColor = activeBallColor;
                    ctx.shadowBlur = 6;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
            }
        }

        function drawPlayers() {
            fieldPlayers.forEach(player => player.draw());
        }

        function initializeFieldPlayers() {
            if (!game.fieldCoords) return;
            
            const coords = game.fieldCoords;
            const size = game.diamondSize;
            fieldPlayers = [];

            // FIXED: When Pink is batting (Red team), Pink should be the batter
            // When Purple is fielding (Blue team), Purple should be the fielders
            // Determine which team is currently batting to set colors correctly
            const battingTeam = game.half === 'top' ? game.awayTeam : game.homeTeam;
            
            // Set colors based on who is batting
            let battingColor, fieldingColor;
            if (battingTeam === game.awayTeam) {
                // Away team (Red) is batting
                battingColor = colors.playerRed;
                fieldingColor = colors.playerBlue;
            } else {
                // Home team (Blue) is batting  
                battingColor = colors.playerBlue;
                fieldingColor = colors.playerRed;
            }

            const positions = [
                { pos: 'P', x: coords.pitcher.x, y: coords.pitcher.y, color: fieldingColor },
                { pos: 'C', x: coords.home.x, y: coords.home.y + 40, color: fieldingColor },
                { pos: '1B', x: coords.first.x + 30, y: coords.first.y + 30, color: fieldingColor },
                { pos: '2B', x: coords.second.x + size * 0.2, y: coords.second.y + size * 0.2, color: fieldingColor },
                { pos: 'SS', x: coords.second.x - size * 0.2, y: coords.second.y + size * 0.2, color: fieldingColor },
                { pos: '3B', x: coords.third.x - 30, y: coords.third.y + 30, color: fieldingColor },
                { pos: 'LF', x: coords.third.x - size * 0.5, y: coords.third.y - size * 0.3, color: fieldingColor },
                { pos: 'CF', x: coords.second.x, y: coords.second.y - size * 0.6, color: fieldingColor },
                { pos: 'RF', x: coords.first.x + size * 0.5, y: coords.first.y - size * 0.3, color: fieldingColor }
            ];

            positions.forEach(p => {
                fieldPlayers.push(new Player(p.x, p.y, p.color, p.pos));
            });

            // Batter uses the batting team's color
            fieldPlayers.push(new Player(coords.home.x - 40, coords.home.y, battingColor, 'BAT'));
        }

        function drawBallAnimation(from, to, callback) {
            drawBallArc(from, to, 800, callback);
        }

        function drawGameScreen() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawField();
            drawPlayers();
            drawScoreboard();
        }

        function drawTransitionScreen() {
            // Draw field background
            drawField();
            
            // Create dark overlay
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Main transition box
            const boxWidth = 800;
            const boxHeight = 250; // Reduced height since we removed outs display
            const boxX = canvas.width / 2 - boxWidth / 2;
            const boxY = canvas.height / 2 - boxHeight / 2;
            
            // Box background with gradient
            const gradient = ctx.createLinearGradient(boxX, boxY, boxX, boxY + boxHeight);
            gradient.addColorStop(0, 'rgba(20, 48, 30, 0.95)');
            gradient.addColorStop(1, 'rgba(10, 30, 15, 0.95)');
            ctx.fillStyle = gradient;
            ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
            
            // Box border with glow
            ctx.strokeStyle = '#4aff9e';
            ctx.lineWidth = 4;
            ctx.shadowColor = '#4aff9e';
            ctx.shadowBlur = 15;
            ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);
            ctx.shadowBlur = 0;
            
            // Title text
            ctx.font = 'bold 48px monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = '#4aff9e';
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 3;
            
            const ordinals = ['', '1st', '2nd', '3rd', '4th', '5th', '6th', '7th', '8th', '9th'];
            const inningText = ordinals[game.currentInning] || `${game.currentInning}th`;
            const halfText = game.half === 'top' ? 'TOP' : 'BOTTOM';
            
            const titleText = `${halfText} OF THE ${inningText} INNING`;
            ctx.strokeText(titleText, canvas.width / 2, boxY + 70);
            ctx.fillText(titleText, canvas.width / 2, boxY + 70);
            
            // Team batting info
            ctx.font = 'bold 32px monospace';
            const battingTeam = game.half === 'top' ? game.awayTeam : game.homeTeam;
            const battingText = `${battingTeam.toUpperCase()} BATTING`;
            ctx.fillStyle = '#ffffff';
            ctx.strokeText(battingText, canvas.width / 2, boxY + 130);
            ctx.fillText(battingText, canvas.width / 2, boxY + 130);
            
            // Score display - FIXED: Always show away team first, then home team
            ctx.font = 'bold 24px monospace';
            const scoreText = `SCORE: ${game.awayTeam} ${game.score.Red} - ${game.score.Blue} ${game.homeTeam}`;
            ctx.fillStyle = '#cccccc';
            ctx.strokeText(scoreText, canvas.width / 2, boxY + 190);
            ctx.fillText(scoreText, canvas.width / 2, boxY + 190);
            
            // Removed outs display since it's always 0 at the start of each half-inning
        }

        function drawSwingMenu() {
            drawGameScreen();
            
            const padding = 20;
            const itemHeight = 50;
            const menuWidth = 280;
            const menuHeight = game.menuOptions.length * itemHeight + padding * 2;
            const menuX = 30;
            const menuY = Math.max(padding, Math.min(
                canvas.height / 2 - menuHeight / 2,
                canvas.height - menuHeight - padding
            ));

            game.menuBounds = [];

            // Modern menu background with gradient
            const gradient = ctx.createLinearGradient(menuX, menuY, menuX, menuY + menuHeight);
            gradient.addColorStop(0, colors.menuBg);
            gradient.addColorStop(1, 'rgba(10, 15, 30, 0.95)');
            ctx.fillStyle = gradient;
            ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
            ctx.shadowBlur = 20;
            ctx.fillRect(menuX, menuY, menuWidth, menuHeight);
            ctx.shadowBlur = 0;

            // Modern border
            ctx.strokeStyle = colors.menuBorder;
            ctx.lineWidth = 3;
            ctx.strokeRect(menuX, menuY, menuWidth, menuHeight);

            // Menu options
            ctx.font = 'bold 18px monospace';
            ctx.textAlign = 'left';
            
            game.menuOptions.forEach((option, i) => {
                const itemY = menuY + padding + i * itemHeight;
                const isSelected = i === game.selectedIndex;
                
                // Store bounds for click detection
                game.menuBounds.push({
                    x: menuX,
                    y: itemY,
                    width: menuWidth,
                    height: itemHeight
                });
                
                // Selection highlight with modern gradient
                if (isSelected) {
                    const selGradient = ctx.createLinearGradient(menuX + 5, itemY, menuX + menuWidth - 5, itemY);
                    selGradient.addColorStop(0, 'rgba(255, 235, 59, 0.2)');
                    selGradient.addColorStop(0.5, 'rgba(255, 235, 59, 0.4)');
                    selGradient.addColorStop(1, 'rgba(255, 235, 59, 0.2)');
                    ctx.fillStyle = selGradient;
                    ctx.fillRect(menuX + 5, itemY + 5, menuWidth - 10, itemHeight - 10);
                    
                    ctx.strokeStyle = colors.menuSelected;
                    ctx.lineWidth = 2;
                    ctx.strokeRect(menuX + 5, itemY + 5, menuWidth - 10, itemHeight - 10);
                }
                
                // Text
                ctx.fillStyle = isSelected ? colors.menuSelected : colors.menuText;
                ctx.textBaseline = 'middle';
                ctx.fillText(isSelected ? `▶ ${option}` : `  ${option}`, menuX + 20, itemY + itemHeight / 2);
            });
        }

        function drawPitchMenu() {
            drawGameScreen();
            
            const padding = 20;
            const itemHeight = 50;
            const menuWidth = 280;
            const menuHeight = game.menuOptions.length * itemHeight + padding * 2;
            const menuX = 30;
            const menuY = Math.max(padding, Math.min(
                canvas.height / 2 - menuHeight / 2,
                canvas.height - menuHeight - padding
            ));

            game.menuBounds = [];

            // Modern menu background
            const gradient = ctx.createLinearGradient(menuX, menuY, menuX, menuY + menuHeight);
            gradient.addColorStop(0, colors.menuBg);
            gradient.addColorStop(1, 'rgba(10, 15, 30, 0.95)');
            ctx.fillStyle = gradient;
            ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
            ctx.shadowBlur = 20;
            ctx.fillRect(menuX, menuY, menuWidth, menuHeight);
            ctx.shadowBlur = 0;

            ctx.strokeStyle = colors.menuBorder;
            ctx.lineWidth = 3;
            ctx.strokeRect(menuX, menuY, menuWidth, menuHeight);

            // Menu title
            ctx.font = 'bold 20px monospace';
            ctx.fillStyle = colors.menuBorder;
            ctx.textAlign = 'center';
            ctx.fillText('CHOOSE PITCH', menuX + menuWidth / 2, menuY - 10);

            ctx.font = 'bold 18px monospace';
            ctx.textAlign = 'left';
            
            game.menuOptions.forEach((option, i) => {
                const itemY = menuY + padding + i * itemHeight;
                const isSelected = i === game.selectedIndex;
                const isRepeatRisk = (game.lastPitchType === option && game.samePitchCount >= 2);
                const isRecommended = (option === game.recommendedPitch);
                
                game.menuBounds.push({
                    x: menuX,
                    y: itemY,
                    width: menuWidth,
                    height: itemHeight
                });
                
                // Selection highlight with modern gradient
                if (isSelected) {
                    const selGradient = ctx.createLinearGradient(menuX + 5, itemY, menuX + menuWidth - 5, itemY);
                    selGradient.addColorStop(0, 'rgba(255, 235, 59, 0.2)');
                    selGradient.addColorStop(0.5, 'rgba(255, 235, 59, 0.4)');
                    selGradient.addColorStop(1, 'rgba(255, 235, 59, 0.2)');
                    ctx.fillStyle = selGradient;
                    ctx.fillRect(menuX + 5, itemY + 5, menuWidth - 10, itemHeight - 10);
                    
                    ctx.strokeStyle = colors.menuSelected;
                    ctx.lineWidth = 2;
                    ctx.strokeRect(menuX + 5, itemY + 5, menuWidth - 10, itemHeight - 10);
                }
                
                // Warning border for repeat risk
                if (isRepeatRisk) {
                    ctx.strokeStyle = '#ff5252'; // red
                    ctx.lineWidth = 3;
                    ctx.strokeRect(menuX + 5, itemY + 5, menuWidth - 10, itemHeight - 10);
                }

                // Hint border for recommended pitch
                if (isRecommended) {
                    ctx.strokeStyle = '#69f0ae'; // green
                    ctx.lineWidth = 3;
                    ctx.strokeRect(menuX + 9, itemY + 9, menuWidth - 18, itemHeight - 18);
                }
                
                // Text with labels
                const label = isRecommended ? ' ✅' : (isRepeatRisk ? ' ⚠️' : '');
                ctx.fillStyle = isSelected ? colors.menuSelected : colors.menuText;
                ctx.textBaseline = 'middle';
                ctx.fillText(isSelected ? `▶ ${option}${label}` : `  ${option}${label}`, menuX + 20, itemY + itemHeight / 2);
            });
        }

        function showPitchMenu() {
            game.menuOptions = ['Fastball', 'Curveball', 'Slider', 'Knuckleball', 'Changeup'];
            
            // Only recommend a pitch when there's a warning (red highlight)
            // Check if any pitch has a warning first
            const hasWarningPitch = game.menuOptions.some(option => 
                game.lastPitchType === option && game.samePitchCount >= 2
            );
            
            if (hasWarningPitch && !game.recommendedPitch) {
                // Only suggest when there's a warning and no current recommendation
                const availablePitches = game.menuOptions.filter(option => 
                    !(game.lastPitchType === option && game.samePitchCount >= 2)
                );
                if (availablePitches.length > 0) {
                    game.recommendedPitch = availablePitches[Math.floor(Math.random() * availablePitches.length)];
                }
            }
            
            game.selectedIndex = -1; // Require spacebar press first
            game.menuReady = false; // Reset menu readiness
            game.hasScanned = false; // Reset scan flag
            drawPitchMenu();
            speak("Choose your pitch.");
        }

        function processPitchSelection(selected) {
            const pitchType = game.menuOptions[selected];
            game.selectedPitch = pitchType;
            
            // Check if the selected pitch was the recommended one
            const wasRecommended = (pitchType === game.recommendedPitch);
            
            // If recommended pitch was selected, clear the recommendation
            if (wasRecommended) {
                game.recommendedPitch = null;
                game.recommendedPitchTimer = 0;
            }
            
            if (game.lastPitchType === pitchType) {
                game.samePitchCount++;
            } else {
                game.samePitchCount = 1;
            }
            game.lastPitchType = pitchType;
            
            const locations = ['Inside', 'Middle', 'Outside'];
            game.selectedPitchLocation = locations[Math.floor(Math.random() * locations.length)];
            
            // IMMEDIATELY remove the pitch menu and return to game view
            game.mode = 'GAMEPLAY';
            drawGameScreen();
            
            speak(`Pitch: ${pitchType} ${game.selectedPitchLocation}`);
            
            // Increased delay to allow TTS to finish speaking the pitch selection
            setTimeout(() => processPitch(pitchType), 3000);
        }

        function drawColorSelectMenu() {
            // Modern gradient background (same as main menu)
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#000428');
            gradient.addColorStop(1, '#004e92');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            drawField();
            
            // Title
            ctx.font = 'bold 36px monospace';
            ctx.textAlign = 'center';
            ctx.fillStyle = '#4a9eff';
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 3;
            ctx.strokeText("CHOOSE TEAM COLOR", canvas.width / 2, 120);
            ctx.fillText("CHOOSE TEAM COLOR", canvas.width / 2, 120);
            
            // Color selector panel
            const padding = 20;
            const itemHeight = 60;
            const menuWidth = 400;
            const menuHeight = 2 * itemHeight + padding * 2; // Color selector + Play Ball button
            const menuX = canvas.width / 2 - menuWidth / 2;
            const menuY = Math.max(200, Math.min(
                canvas.height / 2 - menuHeight / 2,
                canvas.height - menuHeight - padding
            ));

            game.menuBounds = [];

            // Modern menu background with gradient
            const menuGradient = ctx.createLinearGradient(menuX, menuY, menuX, menuY + menuHeight);
            menuGradient.addColorStop(0, colors.menuBg);
            menuGradient.addColorStop(1, 'rgba(10, 15, 30, 0.95)');
            ctx.fillStyle = menuGradient;
            ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
            ctx.shadowBlur = 20;
            ctx.fillRect(menuX, menuY, menuWidth, menuHeight);
            ctx.shadowBlur = 0;

            // Modern border
            ctx.strokeStyle = colors.menuBorder;
            ctx.lineWidth = 3;
            ctx.strokeRect(menuX, menuY, menuWidth, menuHeight);

            // Color toggle selector
            const colorItemY = menuY + padding;
            const isColorSelected = game.selectedIndex === 0;
            
            // Store bounds for color selector
            game.menuBounds.push({
                x: menuX,
                y: colorItemY,
                width: menuWidth,
                height: itemHeight
            });
            
            // Selection highlight for color selector
            if (isColorSelected) {
                const selGradient = ctx.createLinearGradient(menuX + 5, colorItemY, menuX + menuWidth - 5, colorItemY);
                selGradient.addColorStop(0, 'rgba(255, 235, 59, 0.2)');
                selGradient.addColorStop(0.5, 'rgba(255, 235, 59, 0.4)');
                selGradient.addColorStop(1, 'rgba(255, 235, 59, 0.2)');
                ctx.fillStyle = selGradient;
                ctx.fillRect(menuX + 5, colorItemY + 5, menuWidth - 10, itemHeight - 10);
                
                ctx.strokeStyle = colors.menuSelected;
                ctx.lineWidth = 2;
                ctx.strokeRect(menuX + 5, colorItemY + 5, menuWidth - 10, itemHeight - 10);
            }
            
            // Color display with color box and name
            const currentColor = colorOptions[game.currentColorIndex || 0];
            const colorBoxSize = 30;
            const colorBoxX = menuX + 30;
            const colorBoxY = colorItemY + (itemHeight - colorBoxSize) / 2;
            
            // Draw color box
            ctx.fillStyle = currentColor.color;
            ctx.fillRect(colorBoxX, colorBoxY, colorBoxSize, colorBoxSize);
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.strokeRect(colorBoxX, colorBoxY, colorBoxSize, colorBoxSize);
            
            // Draw color name
            ctx.font = 'bold 24px monospace';
            ctx.fillStyle = isColorSelected ? colors.menuSelected : colors.menuText;
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            const colorText = isColorSelected ? `▶ TEAM COLOR: ${currentColor.name}` : `  TEAM COLOR: ${currentColor.name}`;
            ctx.fillText(colorText, colorBoxX + colorBoxSize + 20, colorItemY + itemHeight / 2);

            // Play Ball button
            const playButtonY = menuY + padding + itemHeight;
            const isPlaySelected = game.selectedIndex === 1;
            
            // Store bounds for play button
            game.menuBounds.push({
                x: menuX,
                y: playButtonY,
                width: menuWidth,
                height: itemHeight
            });
            
            // Selection highlight for play button
            if (isPlaySelected) {
                const selGradient = ctx.createLinearGradient(menuX + 5, playButtonY, menuX + menuWidth - 5, playButtonY);
                selGradient.addColorStop(0, 'rgba(255, 235, 59, 0.2)');
                selGradient.addColorStop(0.5, 'rgba(255, 235, 59, 0.4)');
                selGradient.addColorStop(1, 'rgba(255, 235, 59, 0.2)');
                ctx.fillStyle = selGradient;
                ctx.fillRect(menuX + 5, playButtonY + 5, menuWidth - 10, itemHeight - 10);
                
                ctx.strokeStyle = colors.menuSelected;
                ctx.lineWidth = 2;
                ctx.strokeRect(menuX + 5, playButtonY + 5, menuWidth - 10, itemHeight - 10);
            }
            
            // Play Ball button text
            ctx.font = 'bold 28px monospace';
            ctx.fillStyle = isPlaySelected ? colors.menuSelected : colors.menuText;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            const playText = isPlaySelected ? `▶ PLAY BALL!` : `PLAY BALL!`;
            ctx.fillText(playText, menuX + menuWidth / 2, playButtonY + itemHeight / 2);
            
            // Instructions
            ctx.font = 'bold 20px monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'alphabetic';
            ctx.fillStyle = '#ffffff';
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            ctx.strokeText("SPACE: Scan Options | ENTER: Select", canvas.width / 2, canvas.height - 50);
            ctx.fillText("SPACE: Scan Options | ENTER: Select", canvas.width / 2, canvas.height - 50);
        }

        // ============= GAME LOGIC =============
        function resetGameState() {
            game.currentInning = 1;
            // Randomize who bats first - 50% chance for each team
            game.half = Math.random() < 0.5 ? 'top' : 'bottom';
            game.outs = 0;
            game.score = { Blue: 0, Red: 0 };
            game.bases = { first: null, second: null, third: null };
            game.balls = 0;
            game.strikes = 0;
            game.firstPitch = true;
            game.samePitchCount = 0;
            game.lastPitchType = null;
        }

        function startGame() {
            resetGameState();
            game.mode = 'GAMEPLAY';
            pauseButton.classList.add('visible');
            drawGameScreen();
            initializeFieldPlayers();
            setTimeout(() => nextPlay(), 1000);
        }

        function announceHalfInning() {
            // Set mode to transition screen
            game.mode = 'HALF_INNING_TRANSITION';
            
            // Draw the transition screen
            drawTransitionScreen();
            
            // Create the announcement text
            const ordinals = ['', 'First', 'Second', 'Third', 'Fourth', 'Fifth', 'Sixth', 'Seventh', 'Eighth', 'Ninth'];
            const inningText = ordinals[game.currentInning] || game.currentInning;
            const halfText = game.half === 'top' ? 'Top' : 'Bottom';
            
            // Determine which team is batting based on the half inning
            // Top half: away team (Red) bats
            // Bottom half: home team (Blue) bats
            const battingTeam = game.half === 'top' ? game.awayTeam : game.homeTeam;
            const announcement = `${halfText} of the ${inningText} inning. ${battingTeam} batting.`;
            
            speak(announcement);
            
            // IMPORTANT: Set firstPitch to false AFTER the announcement
            // so nextPlay() knows to actually start the gameplay
            game.firstPitch = false;
            
            // Give plenty of time for TTS to complete and user to read
            setTimeout(() => {
                game.mode = 'GAMEPLAY';
                nextPlay();
            }, 6000); // Increased to 6 seconds for better TTS timing
        }

        function nextPlay() {
            // If this is the first pitch of the half-inning, announce it
            if (game.firstPitch) {
                announceHalfInning();
                return;
            }

            if (game.outs >= 3) {
                endHalfInning();
            } else {
                // Determine batting/pitching based on which team is batting this half
                // The player (Red team) should bat when Red team is the batting team
                // The player (Red team) should pitch when Blue team is the batting team
                
                const battingTeam = game.half === 'top' ? game.awayTeam : game.homeTeam;
                const playerTeam = game.awayTeam; // Player is always the away team (Red)
                
                if (battingTeam === playerTeam) {
                    // Player's team is batting - player bats
                    startBattingPhase();
                } else {
                    // Opponent's team is batting - player pitches
                    startPitchingPhase();
                }
            }
        }

        function startBattingPhase() {
            game.mode = 'BATTING';
            simulateComputerPitch();
            speak("Pitcher throws the ball.");
            
            setTimeout(() => showSwingMenu(), 1500);
        }

        function simulateComputerPitch() {
            const pitchTypes = ['Fastball', 'Curveball', 'Slider', 'Knuckleball', 'Changeup'];
            const locations = ['Inside', 'Middle', 'Outside'];
            game.selectedPitch = pitchTypes[Math.floor(Math.random() * pitchTypes.length)];
            game.selectedPitchLocation = locations[Math.floor(Math.random() * locations.length)];
        }

        function showSwingMenu() {
            game.menuOptions = ['Normal Swing', 'Power Swing', 'Hold', 'Bunt'];
            
            if (game.bases.first && !game.bases.second) {
                game.menuOptions.push('Steal 2nd Base');
            }
            if (game.bases.second && !game.bases.third) {
                game.menuOptions.push('Steal 3rd Base');
            }
            
            game.selectedIndex = -1; // Require spacebar press first
            game.menuReady = false; // Reset menu readiness
            game.hasScanned = false; // Reset scan flag
            drawSwingMenu();
        }

        function processBattingSelection(selected) {
            const option = game.menuOptions[selected];
            let outcome = null;
            let terminal = false;

            if (option.includes('Steal')) {
                const base = option.includes('2nd') ? 'second' : 'third';
                const success = Math.random() < (base === 'second' ? 0.5 : 0.3);
                
                if (success) {
                    const fromBase = base === 'second' ? 'first' : 'second';
                    
                    // Store the base update to execute after animation
                    game.pendingBaseUpdate = () => {
                        game.bases[base] = game.bases[fromBase];
                        game.bases[fromBase] = null;
                    };
                    
                    speak(`Steal successful!`);
                    
                    // Animate runner stealing base
                    const stealOutcome = base === 'second' ? 'Steal Second' : 'Steal Third';
                    startRunnerAnimation(stealOutcome, () => finishPlay(null));
                } else {
                    game.bases[base === 'second' ? 'first' : 'second'] = null;
                    game.outs++;
                    speak(`Steal failed. Runner is out.`);
                    finishPlay(null);
                }
                terminal = true;
            } else if (option === 'Bunt') {
                // Bunt probabilities: 40% out, 30% foul, 30% single
                const rand = Math.random();
                if (rand < 0.4) {
                    outcome = 'Ground Out';
                } else if (rand < 0.7) {
                    outcome = 'Foul';
                } else {
                    outcome = 'Single';
                }
                
                terminal = outcome !== 'Foul';
                
                if (outcome === 'Ground Out') {
                    // Batter is out, but runners advance
                    game.outs++;
                    
                    // Store the base update to execute after animation - runners advance
                    game.pendingBaseUpdate = () => {
                        if (game.bases.second) game.bases.third = game.bases.second;
                        if (game.bases.first) game.bases.second = game.bases.first;
                        game.bases.first = null; // Batter is out, doesn't reach first
                    };
                } else if (outcome === 'Single') {
                    // Store the base update to execute after animation - bunt single
                    game.pendingBaseUpdate = () => {
                        if (game.bases.second) game.bases.third = game.bases.second;
                        if (game.bases.first) game.bases.second = game.bases.first;
                        game.bases.first = 'user'; // Batter reaches first
                    };
                } else if (outcome === 'Foul') {
                    // Foul ball - count as strike if less than 2 strikes
                    if (game.strikes < 2) game.strikes++;
                }
                
                if (outcome === 'Foul') {
                    // Just show foul ball animation, no base running
                    const from = { x: game.fieldCoords.home.x - 40, y: game.fieldCoords.home.y };
                    const to = { x: Math.random() < 0.5 ? 100 : canvas.width - 100, y: canvas.height - 100 };
                    drawBallAnimation(from, to, () => finishPlay(outcome));
                } else {
                    // Show ball animation first, then runner animation for single/out
                    const from = { x: game.fieldCoords.home.x - 40, y: game.fieldCoords.home.y };
                    const to = { x: game.fieldCoords.first.x + 50, y: game.fieldCoords.first.y + 50 };
                    
                    drawBallAnimation(from, to, () => {
                        if (outcome === 'Single') {
                            startRunnerAnimation('Single', () => finishPlay(outcome));
                        } else {
                            // For Ground Out, still animate any base runners advancing
                            if (game.bases.first || game.bases.second) {
                                startRunnerAnimation('Bunt Advance', () => finishPlay(outcome));
                            } else {
                                finishPlay(outcome);
                            }
                        }
                    });
                }
            } else {
                outcome = simulateBatting(option);
                terminal = ['Single', 'Double', 'Triple', 'Home Run', 'Walk', 'Strike Out', 'Pop Fly Out', 'Ground Out'].includes(outcome);
                
                processBattingOutcome(outcome, terminal);
            }
        }

        function simulateBatting(swing) {
            if (swing === 'Hold') {
                return game.selectedPitchLocation === 'Outside' ? 'Ball' : (Math.random() < 0.6 ? 'Ball' : 'Strike');
            }
            
            const weights = swing === 'Power Swing' ? 
                { Strike: 55, Foul: 10, 'Pop Fly Out': 15, 'Home Run': 8, Double: 7, Single: 5 } :
                { Strike: 35, Foul: 20, 'Pop Fly Out': 10, 'Ground Out': 10, Single: 18, Double: 7, Triple: 4, 'Home Run': 1 };
            
            return weightedChoice(weights);
        }

        function processBattingOutcome(outcome, terminal) {
            speak(`Result: ${outcome}`);
            
            if (outcome === 'Strike') {
                game.strikes++;
                if (game.strikes >= 3) {
                    outcome = 'Strike Out';
                    game.outs++;
                    terminal = true;
                }
            } else if (outcome === 'Ball') {
                game.balls++;
                if (game.balls >= 4) {
                    outcome = 'Walk';
                    // Store the base update to execute after animation (though Walk doesn't animate)
                    updateBases('Walk', 'user');
                    terminal = true;
                }
            } else if (outcome === 'Foul') {
                if (game.strikes < 2) game.strikes++;
            } else if (['Pop Fly Out', 'Ground Out'].includes(outcome)) {
                if (outcome === 'Ground Out' && game.bases.first && Math.random() < 0.5) {
                    game.outs += 2;
                    game.bases.first = null;
                    outcome = 'Double Play';
                } else {
                    game.outs++;
                }
            } else if (['Single', 'Double', 'Triple', 'Home Run'].includes(outcome)) {
                // Store the base update to execute after animation
                game.pendingBaseUpdate = () => {
                    updateBases(outcome, 'user');
                };
            }

            if (terminal) {
                game.balls = 0;
                game.strikes = 0;
            }

            if (['Single', 'Double', 'Triple', 'Home Run', 'Pop Fly Out', 'Foul'].includes(outcome)) {
                const from = game.fieldCoords.home;
                let to = game.fieldCoords.second;
                
                if (outcome === 'Home Run') {
                    to = { x: canvas.width / 2, y: 100 };
                }
                
                // Show ball animation first, then runner animation for hits
                drawBallFlightAndThrow(from, outcome, () => {
                    if (['Single', 'Double', 'Triple', 'Home Run'].includes(outcome)) {
                        // Start runner animation after ball animation completes
                        startRunnerAnimation(outcome, () => finishPlay(outcome));
                    } else {
                        finishPlay(outcome);
                    }
                });
            } else {
                finishPlay(outcome);
            }
        }

        function startPitchingPhase() {
            game.mode = 'PITCHING';
            showPitchMenu();
        }

        function processPitch(pitchType) {
            const probabilities = {
                Fastball: { strike: 45, ball: 20, hit: 35 },
                Curveball: { strike: 40, ball: 25, hit: 35 },
                Slider: { strike: 45, ball: 30, hit: 25 },
                Knuckleball: { strike: 40, ball: 30, hit: 30 },
                Changeup: { strike: 40, ball: 22, hit: 38 }
            };
            
            let { strike, ball, hit } = probabilities[pitchType] || probabilities.Fastball;
            
            if (game.samePitchCount > 2) {
                hit += 10 * (game.samePitchCount - 2);
            }
            
            const total = strike + ball + hit;
            const rand = Math.random() * total;
            
            let outcome;
            if (rand < strike) {
                outcome = 'Strike';
            } else if (rand < strike + ball) {
                outcome = 'Ball';
            } else {
                const hitWeights = { Single: 20, Double: 5, Triple: 2, 'Home Run': 1, 'Pop Fly Out': 10, 'Ground Out': 15 };
                outcome = weightedChoice(hitWeights);
            }
            
            processPitchOutcome(outcome);
        }

        function processPitchOutcome(outcome) {
            let terminal = false;
            speak(`Computer batter: ${outcome}`);
            
            if (outcome === 'Strike') {
                game.strikes++;
                if (game.strikes >= 3) {
                    outcome = 'Strike Out';
                    game.outs++;
                    terminal = true;
                }
            } else if (outcome === 'Ball') {
                game.balls++;
                if (game.balls >= 4) {
                    outcome = 'Walk';
                    updateBases('Walk', 'comp');
                    terminal = true;
                }
            } else if (outcome === 'Foul') {
                if (game.strikes < 2) game.strikes++;
            } else if (['Pop Fly Out', 'Ground Out'].includes(outcome)) {
                if (outcome === 'Ground Out' && game.bases.first && Math.random() < 0.5) {
                    game.outs += 2;
                    game.bases.first = null;
                    outcome = 'Double Play';
                } else {
                    game.outs++;
                }
                terminal = true;
            } else if (['Single', 'Double', 'Triple', 'Home Run'].includes(outcome)) {
                updateBases(outcome, 'comp');
                terminal = true;
            }

            if (terminal) {
                game.balls = 0;
                game.strikes = 0;
            }

            // Increased delay to allow TTS to finish speaking the outcome
            setTimeout(() => {
                if (['Single', 'Double', 'Triple', 'Home Run', 'Pop Fly Out', 'Foul'].includes(outcome)) {
                    const from = game.fieldCoords.home;
                    let to = game.fieldCoords.second;
                    
                    if (outcome === 'Home Run') {
                        to = { x: canvas.width / 2, y: 100 };
                    }
                    
                    drawBallFlightAndThrow(from, outcome, () => finishPlay(outcome));
                } else {
                    finishPlay(outcome);
                }
            }, 2000); // Added 2 second delay for TTS to complete
        }

        function updateBases(outcome, batter) {
            // Determine which team scores based on current half and batter
            let team;
            if (game.half === 'top') {
                // Top half - away team (Red) is batting
                team = 'Red';
            } else {
                // Bottom half - home team (Blue) is batting  
                team = 'Blue';
            }
            
            if (outcome === 'Single') {
                if (game.bases.third) game.score[team]++;
                game.bases.third = game.bases.second;
                game.bases.second = game.bases.first;
                game.bases.first = batter;
            } else if (outcome === 'Walk') {
                if (game.bases.first) {
                    if (game.bases.second) {
                        if (game.bases.third) game.score[team]++;
                        game.bases.third = game.bases.second;
                    }
                    game.bases.second = game.bases.first;
                }
                game.bases.first = batter;
            } else if (outcome === 'Double') {
                if (game.bases.third) game.score[team]++;
                if (game.bases.second) game.score[team]++;
                game.bases.third = game.bases.first;
                game.bases.first = null;
                game.bases.second = batter;
            } else if (outcome === 'Triple') {
                ['first', 'second', 'third'].forEach(base => {
                    if (game.bases[base]) {
                        game.score[team]++;
                        game.bases[base] = null;
                    }
                });
                game.bases.third = batter;
            } else if (outcome === 'Home Run') {
                let runs = 1;
                ['first', 'second', 'third'].forEach(base => {
                    if (game.bases[base]) {
                        runs++;
                        game.bases[base] = null;
                    }
                });
                game.score[team] += runs;
            }
        }

        function finishPlay(outcome) {
            drawGameScreen();
            
            // Schedule the unlocking of inputs after play completes with cooldown
            setTimeout(() => {
                unlockInputsAfterPlay();
                
                if (game.outs >= 3) {
                    endHalfInning();
                } else {
                    nextPlay();
                }
            }, 2000);
        }

        function unlockInputsAfterPlay() {
            // Add additional cooldown before unlocking inputs
            setTimeout(() => {
                game.playInProgress = false;
                game.inputsBlocked = false;
                game.menuReady = false;
                game.hasScanned = false;
                game.selectedIndex = -1;
            }, game.playCompleteCooldown);
        }

        function endHalfInning() {
            speak(`Half inning over with ${game.outs} outs.`);
            game.outs = 0;
            game.bases = { first: null, second: null, third: null };
            game.balls = 0;
            game.strikes = 0;

            if (game.half === 'top') {
                if (game.currentInning >= 9 && game.score.Blue > game.score.Red) {
                    endGame();
                    return;
                }
                game.half = 'bottom';
            } else {
                if (game.currentInning >= 9) {
                    if (game.score.Blue > game.score.Red || game.score.Red > game.score.Blue) {
                        endGame();
                        return;
                    }
                }
                game.half = 'top';
                game.currentInning++;
            }

            // Reinitialize field players for the new half-inning
            if (game.fieldCoords) {
                initializeFieldPlayers();
            }

            game.firstPitch = true;
            setTimeout(() => nextPlay(), 4000); // Give time for TTS to finish
        }

        // Remove the problematic swapTeamPositions function since we don't need it
        // Player is always Red (away team), Opponent is always Blue (home team)

        function endGame() {
            game.mode = 'GAME_OVER';
            pauseButton.classList.remove('visible');
            const playerWon = game.score.Red > game.score.Blue;
            
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.font = 'bold 80px monospace';
            ctx.textAlign = 'center';
            ctx.fillStyle = playerWon ? '#00ff00' : '#ff0000';
            ctx.shadowColor = ctx.fillStyle;
            ctx.shadowBlur = 30;
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 4;
            
            const resultText = playerWon ? 'YOU WON!' : 'YOU LOST!';
            ctx.strokeText(resultText, canvas.width / 2, canvas.height / 2);
            ctx.fillText(resultText, canvas.width / 2, canvas.height / 2);
            
            ctx.font = 'bold 36px monospace';
            ctx.fillStyle = '#ffffff';
            ctx.shadowBlur = 10;
            const finalScore = `Final Score: ${game.score.Red} - ${game.score.Blue}`;
            ctx.strokeText(finalScore, canvas.width / 2, canvas.height / 2 + 60);
            ctx.fillText(finalScore, canvas.width / 2, canvas.height / 2 + 60);
            ctx.shadowBlur = 0;
            
            speak(resultText);
            
            // Update season progress
            updateSeasonProgress(playerWon);
            
            setTimeout(() => showMainMenu(), 5000);
        }

        function weightedChoice(weights) {
            const total = Object.values(weights).reduce((a, b) => a + b, 0);
            let rand = Math.random() * total;
            
            for (const [outcome, weight] of Object.entries(weights)) {
                rand -= weight;
                if (rand <= 0) return outcome;
            }
            
            return Object.keys(weights)[0];
        }

        // ============= MAIN MENU =============
        function showMainMenu() {
            game.mode = 'MAIN_MENU';
            game.menuOptions = ['Play Game', 'Settings', 'Exit Game'];
            
            // Add season resume option if active season exists
            if (seasonData.active) {
                const seasonText = `Resume Season (${seasonData.wins}-${seasonData.losses})`;
                game.menuOptions.splice(1, 0, seasonText);
            }
            
            game.selectedIndex = 0;
            pauseButton.classList.remove('visible');
            
            drawMainMenu();
            speak("Benny's Baseball Game");
            playBackgroundMusic();
        }

        function showPlayMenu() {
            game.mode = 'PLAY_MENU';
            game.previousMode = 'MAIN_MENU';
            game.menuOptions = ['Exhibition Mode', 'Season Mode', 'Back'];
            game.selectedIndex = 0;
            
            drawPlayMenu();
            speak("Choose game mode");
        }

        function showSettingsMenu() {
            game.mode = 'SETTINGS_MENU';
            game.menuOptions = [
                `Music: ${audioSystem.musicEnabled ? 'ON' : 'OFF'}`,
                `Sound Effects: ${audioSystem.soundEnabled ? 'ON' : 'OFF'}`,
                `Text-to-Speech: ${audioSystem.ttsEnabled ? 'ON' : 'OFF'}`,
                `Voice: ${audioSystem.voiceType.toUpperCase()}`,
                'Next Track',
                'Reset Season',
                'Back'
            ];
            game.selectedIndex = 0;
            
            drawSettingsMenu();
            speak("Settings menu");
        }

        function showColorSelectMenu(mode) {
            game.mode = 'COLOR_SELECT';
            game.gameMode = mode; // Store whether this is exhibition or season
            game.previousMode = 'PLAY_MENU';
            
            // Initialize color selection
            game.currentColorIndex = 0; // Start with first color
            game.selectedIndex = 0; // Start with color selector focused
            
            drawColorSelectMenu();
            speak(`Choose your team color for ${mode}. Current selection: ${colorOptions[0].name}`);
        }

        function drawMainMenu() {
            // Modern gradient background
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#000428');
            gradient.addColorStop(1, '#004e92');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            drawField();
            
            // Title with modern effects
            ctx.font = 'bold 60px monospace';
            ctx.textAlign = 'center';
            ctx.fillStyle = '#ffffff';
            ctx.shadowColor = '#ff0000';
            ctx.shadowBlur = 30;
            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = 4;
            ctx.strokeText("BENNY'S BASEBALL", canvas.width / 2, 100);
            ctx.fillText("BENNY'S BASEBALL", canvas.width / 2, 100);
            
            // Menu panel similar to swing selection
            const padding = 20;
            const itemHeight = 60;
            const menuWidth = 400;
            const menuHeight = game.menuOptions.length * itemHeight + padding * 2;
            const menuX = canvas.width / 2 - menuWidth / 2;
            const menuY = Math.max(200, Math.min(
                canvas.height / 2 - menuHeight / 2 + 50,
                canvas.height - menuHeight - padding
            ));

            game.menuBounds = [];

            // Modern menu background with gradient
            const menuGradient = ctx.createLinearGradient(menuX, menuY, menuX, menuY + menuHeight);
            menuGradient.addColorStop(0, colors.menuBg);
            menuGradient.addColorStop(1, 'rgba(10, 15, 30, 0.95)');
            ctx.fillStyle = menuGradient;
            ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
            ctx.shadowBlur = 20;
            ctx.fillRect(menuX, menuY, menuWidth, menuHeight);
            ctx.shadowBlur = 0;

            // Modern border
            ctx.strokeStyle = colors.menuBorder;
            ctx.lineWidth = 3;
            ctx.strokeRect(menuX, menuY, menuWidth, menuHeight);

            // Menu options
            ctx.font = 'bold 24px monospace';
            ctx.textAlign = 'left';
            
            game.menuOptions.forEach((option, i) => {
                const itemY = menuY + padding + i * itemHeight;
                const isSelected = i === game.selectedIndex;
                
                // Store bounds for click detection
                game.menuBounds.push({
                    x: menuX,
                    y: itemY,
                    width: menuWidth,
                    height: itemHeight
                });
                
                // Selection highlight with modern gradient
                if (isSelected) {
                    const selGradient = ctx.createLinearGradient(menuX + 5, itemY, menuX + menuWidth - 5, itemY);
                    selGradient.addColorStop(0, 'rgba(255, 235, 59, 0.2)');
                    selGradient.addColorStop(0.5, 'rgba(255, 235, 59, 0.4)');
                    selGradient.addColorStop(1, 'rgba(255, 235, 59, 0.2)');
                    ctx.fillStyle = selGradient;
                    ctx.fillRect(menuX + 5, itemY + 5, menuWidth - 10, itemHeight - 10);
                    
                    ctx.strokeStyle = colors.menuSelected;
                    ctx.lineWidth = 2;
                    ctx.strokeRect(menuX + 5, itemY + 5, menuWidth - 10, itemHeight - 10);
                }
                
                // Text
                ctx.fillStyle = isSelected ? colors.menuSelected : colors.menuText;
                ctx.textBaseline = 'middle';
                ctx.textAlign = 'center';
                ctx.fillText(isSelected ? `▶ ${option}` : option, menuX + menuWidth / 2, itemY + itemHeight / 2);
            });
        }

        function drawPlayMenu() {
            ctx.fillStyle = '#000428';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            drawField();
            
            // Title
            ctx.font = 'bold 48px monospace';
            ctx.textAlign = 'center';
            ctx.fillStyle = '#4a9eff';
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 3;
            ctx.strokeText("CHOOSE GAME MODE", canvas.width / 2, 120);
            ctx.fillText("CHOOSE GAME MODE", canvas.width / 2, 120);
            
            // Menu panel similar to swing selection
            const padding = 20;
            const itemHeight = 70;
            const menuWidth = 450;
            const menuHeight = game.menuOptions.length * itemHeight + padding * 2;
            const menuX = canvas.width / 2 - menuWidth / 2;
            const menuY = Math.max(200, Math.min(
                canvas.height / 2 - menuHeight / 2,
                canvas.height - menuHeight - padding
            ));

            game.menuBounds = [];

            // Modern menu background with gradient
            const menuGradient = ctx.createLinearGradient(menuX, menuY, menuX, menuY + menuHeight);
            menuGradient.addColorStop(0, colors.menuBg);
            menuGradient.addColorStop(1, 'rgba(10, 15, 30, 0.95)');
            ctx.fillStyle = menuGradient;
            ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
            ctx.shadowBlur = 20;
            ctx.fillRect(menuX, menuY, menuWidth, menuHeight);
            ctx.shadowBlur = 0;

            // Modern border
            ctx.strokeStyle = colors.menuBorder;
            ctx.lineWidth = 3;
            ctx.strokeRect(menuX, menuY, menuWidth, menuHeight);

            // Menu options
            ctx.font = 'bold 28px monospace';
            ctx.textAlign = 'left';
            
            game.menuOptions.forEach((option, i) => {
                const itemY = menuY + padding + i * itemHeight;
                const isSelected = i === game.selectedIndex;
                
                // Store bounds for click detection
                game.menuBounds.push({
                    x: menuX,
                    y: itemY,
                    width: menuWidth,
                    height: itemHeight
                });
                
                // Selection highlight with modern gradient
                if (isSelected) {
                    const selGradient = ctx.createLinearGradient(menuX + 5, itemY, menuX + menuWidth - 5, itemY);
                    selGradient.addColorStop(0, 'rgba(255, 235, 59, 0.2)');
                    selGradient.addColorStop(0.5, 'rgba(255, 235, 59, 0.4)');
                    selGradient.addColorStop(1, 'rgba(255, 235, 59, 0.2)');
                    ctx.fillStyle = selGradient;
                    ctx.fillRect(menuX + 5, itemY + 5, menuWidth - 10, itemHeight - 10);
                    
                    ctx.strokeStyle = colors.menuSelected;
                    ctx.lineWidth = 2;
                    ctx.strokeRect(menuX + 5, itemY + 5, menuWidth - 10, itemHeight - 10);
                }
                
                // Text
                ctx.fillStyle = isSelected ? colors.menuSelected : colors.menuText;
                ctx.textBaseline = 'middle';
                ctx.textAlign = 'center';
                ctx.fillText(isSelected ? `▶ ${option}` : option, menuX + menuWidth / 2, itemY + itemHeight / 2);
            });
        }

        function drawSettingsMenu() {
            ctx.fillStyle = '#000428';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            drawField();
            
            // Title
            ctx.font = 'bold 48px monospace';
            ctx.textAlign = 'center';
            ctx.fillStyle = '#4a9eff';
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 3;
            ctx.strokeText("SETTINGS", canvas.width / 2, 100);
            ctx.fillText("SETTINGS", canvas.width / 2, 100);
            
            // Menu panel similar to swing selection
            const padding = 20;
            const itemHeight = 55;
            const menuWidth = 500;
            const menuHeight = game.menuOptions.length * itemHeight + padding * 2;
            const menuX = canvas.width / 2 - menuWidth / 2;
            const menuY = Math.max(150, Math.min(
                canvas.height / 2 - menuHeight / 2,
                canvas.height - menuHeight - padding
            ));

            game.menuBounds = [];

            // Modern menu background with gradient
            const menuGradient = ctx.createLinearGradient(menuX, menuY, menuX, menuY + menuHeight);
            menuGradient.addColorStop(0, colors.menuBg);
            menuGradient.addColorStop(1, 'rgba(10, 15, 30, 0.95)');
            ctx.fillStyle = menuGradient;
            ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
            ctx.shadowBlur = 20;
            ctx.fillRect(menuX, menuY, menuWidth, menuHeight);
            ctx.shadowBlur = 0;

            // Modern border
            ctx.strokeStyle = colors.menuBorder;
            ctx.lineWidth = 3;
            ctx.strokeRect(menuX, menuY, menuWidth, menuHeight);

            // Menu options
            ctx.font = 'bold 22px monospace';
            ctx.textAlign = 'left';
            
            game.menuOptions.forEach((option, i) => {
                const itemY = menuY + padding + i * itemHeight;
                const isSelected = i === game.selectedIndex;
                
                // Store bounds for click detection
                game.menuBounds.push({
                    x: menuX,
                    y: itemY,
                    width: menuWidth,
                    height: itemHeight
                });
                
                // Selection highlight with modern gradient
                if (isSelected) {
                    const selGradient = ctx.createLinearGradient(menuX + 5, itemY, menuX + menuWidth - 5, itemY);
                    selGradient.addColorStop(0, 'rgba(255, 235, 59, 0.2)');
                    selGradient.addColorStop(0.5, 'rgba(255, 235, 59, 0.4)');
                    selGradient.addColorStop(1, 'rgba(255, 235, 59, 0.2)');
                    ctx.fillStyle = selGradient;
                    ctx.fillRect(menuX + 5, itemY + 5, menuWidth - 10, itemHeight - 10);
                    
                    ctx.strokeStyle = colors.menuSelected;
                    ctx.lineWidth = 2;
                    ctx.strokeRect(menuX + 5, itemY + 5, menuWidth - 10, itemHeight - 10);
                }
                
                // Text
                ctx.fillStyle = isSelected ? colors.menuSelected : colors.menuText;
                ctx.textBaseline = 'middle';
                ctx.textAlign = 'center';
                ctx.fillText(isSelected ? `▶ ${option}` : `  ${option}`, menuX + menuWidth / 2, itemY + itemHeight / 2);
            });
        }

        // ============= MENU NAVIGATION HANDLERS =============
        function handleMenuSelection() {
            const option = game.menuOptions[game.selectedIndex];
            
            if (game.mode === 'MAIN_MENU') {
                if (option === 'Play Game') {
                    showPlayMenu();
                } else if (option.includes('Resume Season')) {
                    // Start game with current season
                    startGameWithSettings('season', seasonData.teamColor);
                } else if (option === 'Settings') {
                    showSettingsMenu();
                } else if (option === 'Exit Game') {
                    speak("Goodbye!");
                    setTimeout(() => window.close(), 2000);
                }
            } else if (game.mode === 'PLAY_MENU') {
                if (option === 'Exhibition Mode') {
                    showColorSelectMenu('exhibition');
                } else if (option === 'Season Mode') {
                    showColorSelectMenu('season');
                } else if (option === 'Back') {
                    showMainMenu();
                }
            } else if (game.mode === 'SETTINGS_MENU') {
                handleSettingsSelection();
            } else if (game.mode === 'COLOR_SELECT') {
                handleColorSelection();
            }
        }

        function handleSettingsSelection() {
            const option = game.menuOptions[game.selectedIndex];
            
            if (option.includes('Music:')) {
                audioSystem.musicEnabled = !audioSystem.musicEnabled;
                saveAudioSettings();
                if (audioSystem.musicEnabled) {
                    playBackgroundMusic();
                } else {
                    stopMusic();
                }
                showSettingsMenu(); // Refresh display
                speak(audioSystem.musicEnabled ? "Music enabled" : "Music disabled");
            } else if (option.includes('Sound Effects:')) {
                audioSystem.soundEnabled = !audioSystem.soundEnabled;
                saveAudioSettings();
                showSettingsMenu(); // Refresh display
                speak(audioSystem.soundEnabled ? "Sound effects enabled" : "Sound effects disabled");
            } else if (option.includes('Text-to-Speech:')) {
                audioSystem.ttsEnabled = !audioSystem.ttsEnabled;
                saveAudioSettings();
                showSettingsMenu(); // Refresh display
                if (audioSystem.ttsEnabled) {
                    speak("Text to speech enabled");
                }
            } else if (option.includes('Voice:')) {
                const voices = ['default', 'male', 'female'];
                const currentIndex = voices.indexOf(audioSystem.voiceType);
                audioSystem.voiceType = voices[(currentIndex + 1) % voices.length];
                saveAudioSettings();
                showSettingsMenu(); // Refresh display
                speak(`Voice changed to ${audioSystem.voiceType}`);
            } else if (option === 'Next Track') {
                nextTrack();
                speak("Next track");
            } else if (option === 'Reset Season') {
                resetSeason();
                showSettingsMenu(); // Refresh display
                speak("Season reset");
            } else if (option === 'Back') {
                showMainMenu();
            }
        }

        function handleColorSelection() {
            if (game.selectedIndex === 0) {
                // Color selector is selected - cycle through colors
                game.currentColorIndex = (game.currentColorIndex + 1) % colorOptions.length;
                const currentColor = colorOptions[game.currentColorIndex];
                drawColorSelectMenu();
                speak(currentColor.name);
            } else if (game.selectedIndex === 1) {
                // Play Ball button is selected - start the game
                const selectedColor = colorOptions[game.currentColorIndex];
                const colorName = selectedColor.name;
                speak(`Starting game with ${colorName} team`);
                
                if (game.gameMode === 'season') {
                    // Initialize new season
                    seasonData.active = true;
                    seasonData.teamColor = colorName;
                    seasonData.wins = 0;
                    seasonData.losses = 0;
                    seasonData.playedTeams = [];
                    seasonData.inPlayoffs = false;
                    seasonData.inChampionship = false;
                    saveSeasonData();
                }
                
                startGameWithSettings(game.gameMode, colorName);
            }
        }

        function startGameWithSettings(mode, playerColor) {
            // Set team colors
            const playerColorData = colorOptions.find(c => c.name === playerColor);
            let opponentColorData;
            
            if (mode === 'season') {
                opponentColorData = selectOpponentColor();
                saveSeasonData(); // Save updated played teams
            } else {
                // Exhibition - random opponent
                const available = colorOptions.filter(c => c.name !== playerColor);
                opponentColorData = available[Math.floor(Math.random() * available.length)];
            }
            
            // Update visual colors
            colors.playerRed = playerColorData.color;
            colors.playerBlue = opponentColorData.color;
            
            game.homeTeam = opponentColorData.name;
            game.awayTeam = playerColorData.name;
            
            speak(`${playerColorData.name} versus ${opponentColorData.name}`);
            
            // Start the game
            setTimeout(() => startGame(), 2000);
        }

        // ============= VISUAL SETTINGS =============
        const colors = {
            grass: '#2d5016',
            grassLight: '#3a6b1e',
            dirt: '#8b6914',
            dirtLight: '#a67c1a',
            baseLine: '#ffffff',
            playerRed: '#ff0000',
            playerBlue: '#0000ff',
            ballWhite: '#ffffff',
            strikeZone: 'rgba(255, 255, 255, 0.2)',
            menuBg: 'rgba(20, 48, 30, 0.95)',
            menuBorder: '#4aff9e',
            menuSelected: '#ffeb3b',
            menuText: '#ffffff'
        };

        // ============= PAUSE MENU FUNCTIONS =============
        pauseButton.addEventListener('click', () => {
            if (game.mode === 'GAMEPLAY' || game.mode === 'BATTING' || game.mode === 'PITCHING') {
                pauseOverlay.classList.add('active');
                speak('Game paused');
            }
        });

        function resumeGame() {
            pauseOverlay.classList.remove('active');
            speak('Resuming game');
            if (game.mode === 'BATTING') {
                drawSwingMenu();
            } else if (game.mode === 'PITCHING') {
                drawPitchMenu();
            } else {
                drawGameScreen();
            }
        }

        function restartGame() {
            pauseOverlay.classList.remove('active');
            speak('Restarting game');
            startGame();
        }

        function quitToMenu() {
            pauseOverlay.classList.remove('active');
            pauseButton.classList.remove('visible');
            
            // Reset all game state
            game.mode = 'MAIN_MENU';
            game.animating = false;
            game.playInProgress = false;
            game.inputsBlocked = false;
            game.menuReady = false;
            game.hasScanned = false;
            game.selectedIndex = 0;
            
            // Stop any ongoing animations
            if (game.runnerAnimation.active) {
                game.runnerAnimation.active = false;
                game.runnerAnimation.runners = [];
            }
            
            speak('Returning to main menu');
            showMainMenu();
        }

        function showPauseSettings() {
            document.getElementById('pauseMenu').style.display = 'none';
            document.getElementById('pauseSettingsMenu').style.display = 'block';
            updatePauseSettingsDisplay();
        }

        function backToPauseMenu() {
            document.getElementById('pauseSettingsMenu').style.display = 'none';
            document.getElementById('pauseMenu').style.display = 'block';
        }

        function updatePauseSettingsDisplay() {
            document.getElementById('pauseMusicToggle').innerText = `Music: ${audioSystem.musicEnabled ? 'ON' : 'OFF'}`;
            document.getElementById('pauseSoundToggle').innerText = `Sound Effects: ${audioSystem.soundEnabled ? 'ON' : 'OFF'}`;
            document.getElementById('pauseTTSToggle').innerText = `Text-to-Speech: ${audioSystem.ttsEnabled ? 'ON' : 'OFF'}`;
            document.getElementById('pauseVoiceToggle').innerText = `Voice: ${audioSystem.voiceType.toUpperCase()}`;
        }

        function togglePauseMusic() {
            audioSystem.musicEnabled = !audioSystem.musicEnabled;
            saveAudioSettings();
            if (audioSystem.musicEnabled) {
                playBackgroundMusic();
            } else {
                stopMusic();
            }
            updatePauseSettingsDisplay();
            speak(audioSystem.musicEnabled ? "Music enabled" : "Music disabled");
        }

        function togglePauseSound() {
            audioSystem.soundEnabled = !audioSystem.soundEnabled;
            saveAudioSettings();
            updatePauseSettingsDisplay();
            speak(audioSystem.soundEnabled ? "Sound effects enabled" : "Sound effects disabled");
        }

        function togglePauseTTS() {
            audioSystem.ttsEnabled = !audioSystem.ttsEnabled;
            saveAudioSettings();
            updatePauseSettingsDisplay();
            if (audioSystem.ttsEnabled) {
                speak("Text to speech enabled");
            }
        }

        function togglePauseVoice() {
            const voices = ['default', 'male', 'female'];
            const currentIndex = voices.indexOf(audioSystem.voiceType);
            audioSystem.voiceType = voices[(currentIndex + 1) % voices.length];
            saveAudioSettings();
            updatePauseSettingsDisplay();
            speak(`Voice changed to ${audioSystem.voiceType}`);
        }

        function pauseNextTrack() {
            nextTrack();
            speak("Next track");
        }

        function pauseResetSeason() {
            resetSeason();
            updatePauseSettingsDisplay();
            speak("Season reset");
        }

        // ============= INPUT HANDLING =============
        let keyStates = {};

        window.addEventListener('keydown', (e) => {
            if (keyStates[e.key]) return;
            keyStates[e.key] = true;

            if (e.key === ' ') {
                e.preventDefault();
                game.spaceHeld = true;
                game.spaceHoldStart = Date.now();
            }

            if (e.key === 'Enter') {
                e.preventDefault();
                game.returnHeld = true;
                game.returnHoldStart = Date.now();
            }
        });

        window.addEventListener('keyup', (e) => {
            keyStates[e.key] = false;

            if (e.key === ' ') {
                e.preventDefault();
                game.spaceHeld = false;
                handleSpaceRelease();
            }

            if (e.key === 'Enter') {
                e.preventDefault();
                game.returnHeld = false;
                handleEnterRelease();
            }
        });

        function handleSpaceRelease() {
            // Unlock audio on first interaction
            unlockAudio();
            
            // COMPLETE INPUT LOCKDOWN - Block all inputs during play execution
            if (game.playInProgress || game.inputsBlocked) {
                return;
            }
            
            const now = Date.now();
            if (now - game.lastSpaceScan < 200) return;
            
            game.lastSpaceScan = now;
            playSound('scan');
            
            if (game.mode === 'MAIN_MENU') {
                game.selectedIndex = (game.selectedIndex + 1) % game.menuOptions.length;
                drawMainMenu();
                speak(game.menuOptions[game.selectedIndex]);
            } else if (game.mode === 'PLAY_MENU') {
                game.selectedIndex = (game.selectedIndex + 1) % game.menuOptions.length;
                drawPlayMenu();
                speak(game.menuOptions[game.selectedIndex]);
            } else if (game.mode === 'SETTINGS_MENU') {
                game.selectedIndex = (game.selectedIndex + 1) % game.menuOptions.length;
                drawSettingsMenu();
                speak(game.menuOptions[game.selectedIndex]);
            } else if (game.mode === 'COLOR_SELECT') {
                // Toggle between color selector and play button
                game.selectedIndex = (game.selectedIndex + 1) % 2; // Only 2 options: color selector and play button
                
                drawColorSelectMenu();
                
                if (game.selectedIndex === 0) {
                    speak(`Team color selector. Current: ${colorOptions[game.currentColorIndex].name}`);
                } else {
                    speak("Play Ball button");
                }
            } else if (game.mode === 'BATTING') {
                if (game.selectedIndex === -1) {
                    game.selectedIndex = 0;
                } else {
                    game.selectedIndex = (game.selectedIndex + 1) % game.menuOptions.length;
                }
                game.hasScanned = true;
                game.menuReady = true;
                drawSwingMenu();
                speak(game.menuOptions[game.selectedIndex]);
            } else if (game.mode === 'PITCHING') {
                if (game.selectedIndex === -1) {
                    game.selectedIndex = 0;
                } else {
                    game.selectedIndex = (game.selectedIndex + 1) % game.menuOptions.length;
                }
                game.hasScanned = true;
                game.menuReady = true;
                drawPitchMenu();
                speak(game.menuOptions[game.selectedIndex]);
            }
        }

        function handleEnterRelease() {
            // Unlock audio on first interaction
            unlockAudio();
            
            // COMPLETE INPUT LOCKDOWN - Block all inputs during play execution
            if (game.playInProgress || game.inputsBlocked) {
                return;
            }
            
            const now = Date.now();
            const holdDuration = now - game.returnHoldStart;
            
            // Check for action cooldown to prevent rapid auto-play
            if (now - game.lastActionTime < game.actionCooldown) {
                return;
            }
            
            // Check for long press (3+ seconds) to open pause menu
            if (holdDuration >= 3000 && (game.mode === 'GAMEPLAY' || game.mode === 'BATTING' || game.mode === 'PITCHING')) {
                pauseOverlay.classList.add('active');
                speak('Game paused');
                return;
            }
            
            // Menu navigation - always allow
            if (['MAIN_MENU', 'PLAY_MENU', 'SETTINGS_MENU', 'COLOR_SELECT'].includes(game.mode)) {
                game.lastActionTime = now;
                playSound('select');
                handleMenuSelection();
                return;
            }
            
            // Batting/Pitching - ONLY allow if all conditions are met
            if (game.mode === 'BATTING' || game.mode === 'PITCHING') {
                // Must have a valid selection
                if (game.selectedIndex === -1) {
                    return;
                }
                
                // Must have scanned at least once
                if (!game.hasScanned) {
                    return;
                }
                
                // Must be in ready state
                if (!game.menuReady) {
                    return;
                }
                
                // Must not be animating
                if (game.animating) {
                    return;
                }
                
                // LOCK DOWN INPUTS IMMEDIATELY
                game.playInProgress = true;
                game.inputsBlocked = true;
                
                // All conditions met - allow action
                game.lastActionTime = now;
                playSound('select');
                
                if (game.mode === 'BATTING') {
                    processBattingSelection(game.selectedIndex);
                } else if (game.mode === 'PITCHING') {
                    processPitchSelection(game.selectedIndex);
                }
                return;
            }
            
            // All other modes - block completely
            return;
        }

        // ============= CLICK/TOUCH HANDLING =============
        canvas.addEventListener('click', handleCanvasClick);
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            handleClick(touch.clientX - rect.left, touch.clientY - rect.top);
        });

        function handleCanvasClick(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            handleClick(x, y);
        }

        function handleClick(x, y) {
            // Unlock audio on first interaction
            unlockAudio();
            
            // COMPLETE INPUT LOCKDOWN - Block all clicks during play execution
            if (game.playInProgress || game.inputsBlocked) {
                return;
            }
            
            if (game.menuBounds.length === 0) return;

            // Check if click is within any menu item bounds
            for (let i = 0; i < game.menuBounds.length; i++) {
                const bounds = game.menuBounds[i];
                if (x >= bounds.x && x <= bounds.x + bounds.width &&
                    y >= bounds.y && y <= bounds.y + bounds.height) {
                    
                    const now = Date.now();
                    
                    // Apply same protection as Enter key handling
                    if (game.mode === 'MAIN_MENU') {
                        // Main menu - always allow
                        playSound('select');
                        game.selectedIndex = i;
                        if (game.menuOptions[i] === 'Play Game') {
                            showPlayMenu();
                        } else if (game.menuOptions[i] === 'Settings') {
                            showSettingsMenu();
                        } else if (game.menuOptions[i] === 'Exit Game') {
                            speak("Goodbye!");
                            setTimeout(() => window.close(), 2000);
                        } else if (game.menuOptions[i].includes('Resume Season')) {
                            startGameWithSettings('season', seasonData.teamColor);
                        }
                        return;
                    }
                    
                    // Play menu - allow navigation
                    if (game.mode === 'PLAY_MENU') {
                        game.lastActionTime = now;
                        playSound('select');
                        game.selectedIndex = i;
                        handleMenuSelection();
                        return;
                    }
                    
                    // Settings menu - allow navigation
                    if (game.mode === 'SETTINGS_MENU') {
                        game.lastActionTime = now;
                        playSound('select');
                        game.selectedIndex = i;
                        handleSettingsSelection();
                        return;
                    }
                    
                    // Color select menu - allow navigation
                    if (game.mode === 'COLOR_SELECT') {
                        game.lastActionTime = now;
                        playSound('select');
                        game.selectedIndex = i;
                        handleColorSelection();
                        return;
                    }
                    
                    // Batting/Pitching - apply same strict checks as Enter key
                    if (game.mode === 'BATTING' || game.mode === 'PITCHING') {
                        // Check for action cooldown
                        if (now - game.lastActionTime < game.actionCooldown) {
                            return;
                        }
                        
                        // Must not be animating
                        if (game.animating) {
                            return;
                        }
                        
                        // LOCK DOWN INPUTS IMMEDIATELY
                        game.playInProgress = true;
                        game.inputsBlocked = true;
                        
                        // All conditions met - allow action
                        game.lastActionTime = now;
                        playSound('select');
                        game.selectedIndex = i;
                        
                        // Set scan flags since clicking counts as making a selection
                        game.hasScanned = true;
                        game.menuReady = true;
                        
                        if (game.mode === 'BATTING') {
                            processBattingSelection(i);
                        } else if (game.mode === 'PITCHING') {
                            processPitchSelection(i);
                        }
                        return;
                    }
                    
                    break;
                }
            }
        }

        // ============= GAME LOOP =============
        function gameLoop() {
            if (game.mode === 'GAMEPLAY' && !game.animating) {
                drawGameScreen();
            } else if (game.mode === 'HALF_INNING_TRANSITION') {
                drawTransitionScreen();
            }
            
            requestAnimationFrame(gameLoop);
        }

        // ============= INITIALIZE =============
        window.addEventListener('load', () => {
            initializeSeasonData();
            initializeAudioSettings();
            showMainMenu();
            gameLoop();
        });

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            if (game.mode === 'MAIN_MENU') {
                drawMainMenu();
            } else if (game.mode === 'PLAY_MENU') {
                drawPlayMenu();
            } else if (game.mode === 'SETTINGS_MENU') {
                drawSettingsMenu();
            } else if (game.mode === 'COLOR_SELECT') {
                drawColorSelectMenu();
            } else if (game.mode === 'GAMEPLAY') {
                drawGameScreen();
                initializeFieldPlayers();
            } else if (game.mode === 'BATTING') {
                drawSwingMenu();
            } else if (game.mode === 'PITCHING') {
                drawPitchMenu();
            } else if (game.mode === 'HALF_INNING_TRANSITION') {
                drawTransitionScreen();
            }
        });

        // ============= RUNNER ANIMATION FUNCTIONS =============
        function createAllRunnerPaths(outcome, currentBases) {
            if (!game.fieldCoords) return [];
            
            const coords = game.fieldCoords;
            const runners = [];
            
            if (outcome === 'Steal Second') {
                // Only the runner on first base moves
                if (currentBases.first) {
                    runners.push({
                        id: 'first-to-second',
                        color: currentBases.first === 'user' ? colors.playerRed : colors.playerBlue,
                        path: [coords.first, { x: coords.second.x + 20, y: coords.second.y - 20 }, coords.second]
                    });
                }
            } else if (outcome === 'Steal Third') {
                // Only the runner on second base moves
                if (currentBases.second) {
                    runners.push({
                        id: 'second-to-third',
                        color: currentBases.second === 'user' ? colors.playerRed : colors.playerBlue,
                        path: [coords.second, { x: coords.third.x + 20, y: coords.third.y + 20 }, coords.third]
                    });
                }
            } else if (outcome === 'Bunt Advance') {
                // Handle base runners advancing on bunt ground out (batter doesn't run)
                if (currentBases.second) {
                    runners.push({
                        id: 'second-to-third',
                        color: currentBases.second === 'user' ? colors.playerRed : colors.playerBlue,
                        path: [coords.second, { x: coords.third.x + 20, y: coords.third.y + 20 }, coords.third]
                    });
                }
                
                if (currentBases.first) {
                    runners.push({
                        id: 'first-to-second',
                        color: currentBases.first === 'user' ? colors.playerRed : colors.playerBlue,
                        path: [coords.first, { x: coords.second.x + 20, y: coords.second.y - 20 }, coords.second]
                    });
                }
            } else if (['Single', 'Double', 'Triple', 'Home Run'].includes(outcome)) {
                // Batter runs
                const batterPath = [{ x: coords.home.x - 40, y: coords.home.y }];
                const firstApproach = { x: coords.first.x - 20, y: coords.first.y + 20 };
                batterPath.push(firstApproach, coords.first);
                
                if (['Double', 'Triple', 'Home Run'].includes(outcome)) {
                    const secondApproach = { x: coords.second.x + 20, y: coords.second.y - 20 };
                    batterPath.push(secondApproach, coords.second);
                    
                    if (['Triple', 'Home Run'].includes(outcome)) {
                        const thirdApproach = { x: coords.third.x + 20, y: coords.third.y + 20 };
                        batterPath.push(thirdApproach, coords.third);
                        
                        if (outcome === 'Home Run') {
                            const homeApproach = { x: coords.home.x + 20, y: coords.home.y - 20 };
                            batterPath.push(homeApproach, coords.home);
                        }
                    }
                }
                
                runners.push({
                    id: 'batter',
                    color: colors.playerRed,
                    path: batterPath
                });
                
                // Existing runners advance
                if (currentBases.third) {
                    // Runner on third scores
                    runners.push({
                        id: 'third-to-home',
                        color: currentBases.third === 'user' ? colors.playerRed : colors.playerBlue,
                        path: [coords.third, { x: coords.home.x + 20, y: coords.home.y - 20 }, coords.home]
                    });
                }
                
                if (currentBases.second) {
                    if (outcome === 'Double' || outcome === 'Triple' || outcome === 'Home Run') {
                        // Runner scores from second
                        runners.push({
                            id: 'second-to-home',
                            color: currentBases.second === 'user' ? colors.playerRed : colors.playerBlue,
                            path: [coords.second, { x: coords.third.x + 20, y: coords.third.y + 20 }, coords.third, { x: coords.home.x + 20, y: coords.home.y - 20 }, coords.home]
                        });
                    } else {
                        // Runner advances to third
                        runners.push({
                            id: 'second-to-third',
                            color: currentBases.second === 'user' ? colors.playerRed : colors.playerBlue,
                            path: [coords.second, { x: coords.third.x + 20, y: coords.third.y + 20 }, coords.third]
                        });
                    }
                }
                
                if (currentBases.first) {
                    if (outcome === 'Triple' || outcome === 'Home Run') {
                        // Runner scores from first
                        runners.push({
                            id: 'first-to-home',
                            color: currentBases.first === 'user' ? colors.playerRed : colors.playerBlue,
                            path: [coords.first, { x: coords.second.x + 20, y: coords.second.y - 20 }, coords.second, { x: coords.third.x + 20, y: coords.third.y + 20 }, coords.third, { x: coords.home.x + 20, y: coords.home.y - 20 }, coords.home]
                        });
                    } else if (outcome === 'Double') {
                        // Runner advances to third
                        runners.push({
                            id: 'first-to-third',
                            color: currentBases.first === 'user' ? colors.playerRed : colors.playerBlue,
                            path: [coords.first, { x: coords.second.x + 20, y: coords.second.y - 20 }, coords.second, { x: coords.third.x + 20, y: coords.third.y + 20 }, coords.third]
                        });
                    } else {
                        // Runner advances to second
                        runners.push({
                            id: 'first-to-second',
                            color: currentBases.first === 'user' ? colors.playerRed : colors.playerBlue,
                            path: [coords.first, { x: coords.second.x + 20, y: coords.second.y - 20 }, coords.second]
                        });
                    }
                }
            }
            
            return runners;
        }

        function startRunnerAnimation(outcome, callback) {
            // Store current base state before updating
            const currentBases = { ...game.bases };
            const runnerData = createAllRunnerPaths(outcome, currentBases);
            
            if (runnerData.length === 0) {
                if (callback) callback();
                return;
            }
            
            // Initialize all runners
            game.runnerAnimation.active = true;
            game.runnerAnimation.runners = runnerData.map(data => ({
                id: data.id,
                player: new Player(data.path[0].x, data.path[0].y, data.color, 'RUN'),
                path: data.path,
                pathIndex: 0,
                progress: 0,
                speed: 0.008,
                pauseTime: 0,
                pauseDuration: 600,
                completed: false
            }));
            
            game.runnerAnimation.completedAnimations = 0;
            game.runnerAnimation.totalAnimations = game.runnerAnimation.runners.length;
            game.animating = true;
            
            function animateAllRunners() {
                if (!game.runnerAnimation.active) {
                    game.animating = false;
                    // Apply base updates after animation completes
                    if (game.pendingBaseUpdate) {
                        game.pendingBaseUpdate();
                        game.pendingBaseUpdate = null;
                    }
                    if (callback) callback();
                    return;
                }
                
                const currentTime = Date.now();
                let allCompleted = true;
                
                game.runnerAnimation.runners.forEach(runner => {
                    if (runner.completed) return;
                    
                    // Check if we're in a pause at a base
                    if (runner.pauseTime > 0) {
                        if (currentTime - runner.pauseTime < runner.pauseDuration) {
                            allCompleted = false;
                            return;
                        } else {
                            runner.pauseTime = 0;
                            runner.pathIndex++;
                            runner.progress = 0;
                        }
                    }
                    
                    // Check if this runner's animation is complete
                    if (runner.pathIndex >= runner.path.length - 1) {
                        runner.completed = true;
                        game.runnerAnimation.completedAnimations++;
                        return;
                    }
                    
                    allCompleted = false;
                    
                    // Animate between current and next point
                    const from = runner.path[runner.pathIndex];
                    const to = runner.path[runner.pathIndex + 1];
                    
                    // Apply easing function
                    const easedProgress = easeInOutQuad(runner.progress);
                    
                    // Update runner position
                    runner.player.x = from.x + (to.x - from.x) * easedProgress;
                    runner.player.y = from.y + (to.y - from.y) * easedProgress;
                    
                    // Increase progress
                    runner.progress += runner.speed;
                    
                    // Check if we've reached the next point
                    if (runner.progress >= 1) {
                        runner.player.x = to.x;
                        runner.player.y = to.y;
                        
                        // Check if this is a base (pause point)
                        const coords = game.fieldCoords;
                        const isBase = (
                            (Math.abs(to.x - coords.first.x) < 5 && Math.abs(to.y - coords.first.y) < 5) ||
                            (Math.abs(to.x - coords.second.x) < 5 && Math.abs(to.y - coords.second.y) < 5) ||
                            (Math.abs(to.x - coords.third.x) < 5 && Math.abs(to.y - coords.third.y) < 5) ||
                            (Math.abs(to.x - coords.home.x) < 5 && Math.abs(to.y - coords.home.y) < 5)
                        );
                        
                        if (isBase && runner.pathIndex < runner.path.length - 2) {
                            // Pause at base
                            runner.pauseTime = currentTime;
                        } else {
                            // Continue to next segment
                            runner.pathIndex++;
                            runner.progress = 0;
                        }
                    }
                });
                
                if (allCompleted) {
                    game.runnerAnimation.active = false;
                    game.animating = false;
                    // Apply base updates after animation completes
                    if (game.pendingBaseUpdate) {
                        game.pendingBaseUpdate();
                        game.pendingBaseUpdate = null;
                    }
                    if (callback) callback();
                } else {
                    drawGameScreen();
                    drawAllRunningPlayers();
                    requestAnimationFrame(animateAllRunners);
                }
            }
            
            animateAllRunners();
        }

        function drawAllRunningPlayers() {
            if (game.runnerAnimation.active) {
                game.runnerAnimation.runners.forEach(runner => {
                    if (!runner.completed) {
                        // Add running motion effect
                        runner.player.animation += 0.2;
                        runner.player.draw();
                        
                        // Add dust trail effect
                        ctx.fillStyle = 'rgba(139, 105, 20, 0.3)';
                        for (let i = 0; i < 3; i++) {
                            const trailX = runner.player.x - (i + 1) * 8;
                            const trailY = runner.player.y + 8 + Math.random() * 4;
                            ctx.beginPath();
                            ctx.arc(trailX, trailY, 2 - i * 0.5, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                });
            }
        }

        function easeInOutQuad(t) {
            return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
        }

        // ============= BALL FLIGHT AND THROW ANIMATION FUNCTIONS =============
        function getFielderPosition(outcome) {
            if (!game.fieldCoords || !fieldPlayers) return null;
            
            const coords = game.fieldCoords;
            const size = game.diamondSize;
            
            if (outcome === 'Pop Fly Out') {
                // Random outfielder for pop fly
                const outfielders = fieldPlayers.filter(p => ['LF', 'CF', 'RF'].includes(p.position));
                const targetPlayer = outfielders[Math.floor(Math.random() * outfielders.length)];
                return { x: targetPlayer.x, y: targetPlayer.y, player: targetPlayer };
            } else if (outcome === 'Ground Out') {
                // Random infielder for ground out (not pitcher or catcher)
                const infielders = fieldPlayers.filter(p => ['1B', '2B', 'SS', '3B'].includes(p.position));
                const targetPlayer = infielders[Math.floor(Math.random() * infielders.length)];
                return { x: targetPlayer.x, y: targetPlayer.y, player: targetPlayer };
            } else if (outcome === 'Single') {
                // Land in gaps between infielders and outfielders
                const gapOptions = [
                    // Gap between 1B and 2B
                    { x: coords.first.x + size * 0.15, y: coords.first.y + size * 0.15 },
                    // Gap between SS and 3B
                    { x: coords.third.x + size * 0.15, y: coords.third.y + size * 0.15 },
                    // Gap up the middle between 2B and SS
                    { x: coords.second.x, y: coords.second.y + size * 0.25 },
                    // Shallow left field between 3B and LF
                    { x: coords.third.x - size * 0.25, y: coords.third.y - size * 0.15 },
                    // Shallow right field between 1B and RF
                    { x: coords.first.x + size * 0.25, y: coords.first.y - size * 0.15 }
                ];
                return gapOptions[Math.floor(Math.random() * gapOptions.length)];
            } else if (outcome === 'Double') {
                // Land in gaps between outfielders
                const gapOptions = [
                    // Left-center gap
                    { x: coords.third.x - size * 0.35, y: coords.second.y - size * 0.45 },
                    // Right-center gap
                    { x: coords.first.x + size * 0.35, y: coords.second.y - size * 0.45 },
                    // Deep left field gap
                    { x: coords.third.x - size * 0.45, y: coords.third.y - size * 0.35 },
                    // Deep right field gap
                    { x: coords.first.x + size * 0.45, y: coords.first.y - size * 0.35 },
                    // Deep center field
                    { x: coords.second.x, y: coords.second.y - size * 0.65 }
                ];
                return gapOptions[Math.floor(Math.random() * gapOptions.length)];
            } else if (outcome === 'Triple') {
                // Land in deep gaps and corners
                const gapOptions = [
                    // Deep left field corner
                    { x: coords.third.x - size * 0.7, y: coords.second.y - size * 0.6 },
                    // Deep right field corner
                    { x: coords.first.x + size * 0.7, y: coords.second.y - size * 0.6 },
                    // Deep left-center gap
                    { x: coords.third.x - size * 0.5, y: coords.second.y - size * 0.75 },
                    // Deep right-center gap
                    { x: coords.first.x + size * 0.5, y: coords.second.y - size * 0.75 },
                    // Very deep center field
                    { x: coords.second.x + (Math.random() - 0.5) * size * 0.3, y: coords.second.y - size * 0.8 }
                ];
                return gapOptions[Math.floor(Math.random() * gapOptions.length)];
            } else if (outcome === 'Home Run') {
                // Over the fence
                return {
                    x: canvas.width / 2 + (Math.random() - 0.5) * 200,
                    y: 50,
                    player: null
                };
            } else if (outcome === 'Foul') {
                // Foul territory
                const isLeft = Math.random() < 0.5;
                return {
                    x: isLeft ? 100 : canvas.width - 100,
                    y: canvas.height - 100,
                    player: null
                };
            }
            
            return null;
        }

        function drawBallFlightAndThrow(from, outcome, callback) {
            const targetInfo = getFielderPosition(outcome);
            if (!targetInfo) {
                if (callback) callback();
                return;
            }
            
            const to = { x: targetInfo.x, y: targetInfo.y };
            const fielder = targetInfo.player;
            
            // Use ground ball animation for ground outs
            if (outcome === 'Ground Out') {
                drawGroundBall(from, to, fielder, callback);
            } else {
                // Use regular ball arc for other outcomes
                drawBallArc(from, to, 1200, () => {
                    // Second phase: If it's an out and there's a fielder, throw back to pitcher
                    if (outcome === 'Pop Fly Out' && fielder) {
                        const pitcherPos = game.fieldCoords.pitcher;
                        setTimeout(() => {
                            drawBallArc(to, pitcherPos, 800, callback);
                        }, 300); // Brief pause for catch
                    } else {
                        if (callback) callback();
                    }
                });
            }
        }

        function drawGroundBall(from, to, fielder, callback) {
            const startTime = Date.now();
            const duration = 1000; // 1 second for ground ball
            const ballSize = 8;
            const bounceCount = 3; // Number of bounces
            
            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Calculate ball position along the path
                const currentX = from.x + (to.x - from.x) * progress;
                const currentY = from.y + (to.y - from.y) * progress;
                
                // Create bouncing motion - multiple sine waves that decrease in amplitude
                let bounceHeight = 0;
                for (let i = 0; i < bounceCount; i++) {
                    const bounceProgress = progress * bounceCount - i;
                    if (bounceProgress >= 0 && bounceProgress <= 1) {
                        const amplitude = 20 * Math.pow(0.6, i); // Decreasing bounce height
                        bounceHeight += Math.sin(bounceProgress * Math.PI) * amplitude;
                    }
                }
                
                const ballY = currentY - Math.max(0, bounceHeight);

                drawGameScreen();
                
                // Draw ball shadow on ground
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.ellipse(currentX, currentY + 5, 6, 3, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw dust clouds at bounce points
                if (bounceHeight > 0) {
                    const dustIntensity = bounceHeight / 20;
                    ctx.fillStyle = `rgba(139, 105, 20, ${dustIntensity * 0.4})`;
                    for (let j = 0; j < 5; j++) {
                        const dustX = currentX + (Math.random() - 0.5) * 15;
                        const dustY = currentY + Math.random() * 10 + 5;
                        ctx.beginPath();
                        ctx.arc(dustX, dustY, 2 + Math.random() * 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                // Draw ball trail (closer to ground)
                for (let i = 0; i < 3; i++) {
                    const trailProgress = Math.max(0, progress - i * 0.05);
                    const trailX = from.x + (to.x - from.x) * trailProgress;
                    const trailGroundY = from.y + (to.y - from.y) * trailProgress;
                    
                    // Calculate trail bounce
                    let trailBounceHeight = 0;
                    for (let j = 0; j < bounceCount; j++) {
                        const trailBounceProgress = trailProgress * bounceCount - j;
                        if (trailBounceProgress >= 0 && trailBounceProgress <= 1) {
                            const amplitude = 20 * Math.pow(0.6, j);
                            trailBounceHeight += Math.sin(trailBounceProgress * Math.PI) * amplitude;
                        }
                    }
                    
                    const trailY = trailGroundY - Math.max(0, trailBounceHeight);
                    const alpha = 0.3 - i * 0.1;
                    const size = ballSize - i * 2;
                    
                    ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(trailX, trailY, Math.max(1, size), 0, Math.PI * 2);
                    ctx.fill();
                }

                // Draw main ball
                ctx.fillStyle = colors.ballWhite;
                ctx.strokeStyle = '#cccccc';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(currentX, ballY, ballSize, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                
                // Add baseball seams
                ctx.beginPath();
                ctx.arc(currentX, ballY, ballSize * 0.7, 0, Math.PI);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(currentX, ballY, ballSize * 0.7, Math.PI, Math.PI * 2);
                ctx.stroke();

                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    // Ball reached fielder - now the ground out sequence: fielder -> first base -> pitcher
                    if (fielder) {
                        // Step 1: Fielder throws to first base
                        const firstBasePos = game.fieldCoords.first;
                        setTimeout(() => {
                            drawBallArc(to, firstBasePos, 600, () => {
                                // Step 2: First baseman throws back to pitcher
                                const pitcherPos = game.fieldCoords.pitcher;
                                setTimeout(() => {
                                    drawBallArc(firstBasePos, pitcherPos, 600, callback);
                                }, 200); // Brief pause at first base
                            });
                        }, 300); // Brief pause for fielding
                    } else {
                        if (callback) callback();
                    }
                }
            }

            animate();
        }
    </script>
</body>
</html>
``` 
