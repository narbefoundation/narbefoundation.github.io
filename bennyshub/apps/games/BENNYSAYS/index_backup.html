<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Benny Says</title>
  <style>
    html, body { margin: 0; height: 100%; background: #0f172a; color: #e5e7eb; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    #wrap { position: relative; width: 100%; height: 100%; }
    canvas { display: block; width: 100%; height: 100%; background: #0b2239; cursor: pointer; }
    .hint { position: absolute; left: 12px; bottom: 12px; font-size: 12px; opacity: .7; }
  </style>
</head>
<body>
  <div id="wrap">
    <div id="start-overlay" style="position:absolute; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:999; display:flex; justify-content:center; align-items:center; flex-direction:column; color:white; font-size:24px;">
        <div style="margin-bottom:20px;">Tap to Start</div>
        <div style="font-size:16px; opacity:0.8;">Enable Audio</div>
    </div>
    <canvas id="game"></canvas>
    <div class="hint">Space = scan (hold 3s = auto-back every 1.5s). Return = select. Click = direct select.</div>
  </div>

  <!-- Include shared voice manager (REPLACED FOR STANDALONE) -->
  <script src="standalone-utils.js"></script>
  
  <script>
  // Hide overlay on first interaction
  const overlay = document.getElementById('start-overlay');
  function hideOverlay() {
      if(overlay) overlay.style.display = 'none';
  }
  ['click', 'touchstart', 'keydown'].forEach(evt => document.addEventListener(evt, hideOverlay, {once:true}));

  // ====== Constants ======
  const BACK_HOLD_THRESHOLD = 3000;   // ms to engage back-scan
  // BACK_STEP_INTERVAL will be retrieved from NarbeScanManager
  const FORWARD_DEBOUNCE    = 160;    // ms debounce for space release forward step
  const RETURN_DEBOUNCE     = 160;    // ms debounce for return release

  const COLORS = ['#ff5c00', '#5bb0ff', '#39d353', '#a78bfa'];
  const NAMES  = ['Orange','Blue','Green','Purple'];
  const MENU_ITEMS  = ['Easy','Medium','Hard','Settings','Exit'];
  const MENU_COLORS = ['#60a5fa', '#34d399', '#f59e0b', '#8b5cf6', '#ef4444']; // Added purple for Settings

  const HILITE = '#ffffff';
  const BG = '#0b2239';
  const FLASH_LIGHTEN = 0.75;

  // ====== Canvas setup ======
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  let DPR = 1;
  function resize() {
    DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const rect = canvas.getBoundingClientRect();
    const cssW = Math.max(1, Math.floor(rect.width || window.innerWidth || 800));
    const cssH = Math.max(1, Math.floor(rect.height || window.innerHeight || 600));
    canvas.width = cssW * DPR;
    canvas.height = cssH * DPR;
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
  }
  window.addEventListener('resize', resize);
  resize();

  // ====== Audio ======
  let audioCtx = null;
  let masterGain = null;
  let audioUnlocked = false;

  function initAudio() {
    if (audioCtx) return;
    try {
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        if (!AudioContext) return;
        audioCtx = new AudioContext();
        masterGain = audioCtx.createGain();
        masterGain.gain.value = 0.5;
        masterGain.connect(audioCtx.destination);
    } catch (e) {
        console.warn('Audio init failed:', e);
    }
  }

  // IOS UNLOCK
  const unlockEvents = ['touchstart', 'touchend', 'click', 'keydown'];
  function unlockAudio() {
    // 1. Web Audio Unlock
    if (!audioCtx) initAudio();
    if (audioCtx) {
        if (audioCtx.state === 'suspended') {
            audioCtx.resume();
        }
        if (!audioUnlocked) {
            // Play silent buffer
            const buffer = audioCtx.createBuffer(1, 1, 22050); 
            const source = audioCtx.createBufferSource(); 
            source.buffer = buffer; 
            source.connect(audioCtx.destination); 
            source.start(0); 
            audioUnlocked = true;
            console.log("Audio Unlocked");
        }
    }

    // 2. TTS Unlock
    if (window.NarbeVoiceManager && window.NarbeVoiceManager.unlock) {
        window.NarbeVoiceManager.unlock();
    }
    
    // Cleanup listeners if both are unlocked? 
    // Usually keep 'touchstart' active in case context suspends again (rare but possible)
  }
  
  // Attach globallly to ensure we catch it early
  unlockEvents.forEach(evt => document.addEventListener(evt, unlockAudio, {capture: true, passive: false}));

  const TONES = [329.63, 261.63, 392.00, 523.25]; // E4, C4, G4, C5

  function beep(idx, dur) {
    if (!audioCtx) initAudio();
    if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
    if (!audioCtx) return;

    const d = typeof dur === 'number' ? dur : 520;
    try {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = 'sine';
      osc.frequency.value = TONES[idx % TONES.length];
      gain.gain.value = 0.001;
      osc.connect(gain);
      gain.connect(masterGain);
      const now = audioCtx.currentTime;
      gain.gain.setValueAtTime(0.001, now);
      gain.gain.linearRampToValueAtTime(1.0, now + 0.02);
      gain.gain.linearRampToValueAtTime(0.001, now + d/1000);
      osc.start();
      osc.stop(now + d/1000 + 0.02);
    } catch (e) { /* ignore */ }
  }

  // ====== State ======
  const Phase = { TITLE: 'title', SETTINGS: 'settings', SHOWING: 'showing', PLAYER: 'player', GAMEOVER: 'gameover' };
  let phase = Phase.TITLE;
  let sequence = [];
  let playerProgress = 0;
  let round = 0;

  // difficulty
  let colorCount = 4; // set by menu

  // indices
  let highlightIndex = -1; // gameplay scan index -1 (no highlight) then 0..colorCount-1
  const titleItems = MENU_ITEMS.slice();
  let titleHighlight = -1; // -1 (no highlight) then 0..3
  
  // Settings menu state
  let settingsItems = [];
  let settingsHighlight = -1;

  // timers/flags
  let spaceIsDown = false;
  let spaceDownAt = 0;
  let backScanTimer = null;
  let backScanInterval = null;
  let isBackScanActive = false;
  let lastForwardStepAt = 0;
  let lastReturnAt = 0;

  // Auto Scan Logic
  let autoScanTimer = null;

  function startAutoScan() {
    stopAutoScan();
    // Only run if NarbeScanManager says autoScan is on
    if (window.NarbeScanManager && window.NarbeScanManager.getSettings().autoScan) {
       const scanSpeed = window.NarbeScanManager.getScanInterval();
       autoScanTimer = setInterval(() => { stepForward(); }, scanSpeed);
    }
  }

  function stopAutoScan() {
    if (autoScanTimer) {
      clearInterval(autoScanTimer);
      autoScanTimer = null;
    }
  }

  // visuals
  let flashingIndex = -1;
  let flashUntil = 0;

  // Store tile bounds for mouse detection
  let tileBounds = [];
  let menuBounds = [];

  // ====== Utilities ======
  function sleep(ms) { return new Promise(res => setTimeout(res, ms)); }
  function randInt(n) { return Math.floor(Math.random() * n); }
  function speak(text) {
    if (window.NarbeVoiceManager) {
      window.NarbeVoiceManager.speak(text);
    }
  }

  // Robust exit helper: communicates with parent to focus back button
  // ====== Game flow ======
  function startNewGame() {
    stopAutoScan(); // Don't auto-scan during show phase
    sequence = [randInt(colorCount)];
    playerProgress = 0;
    round = 1;
    highlightIndex = -1; // Start with no highlight until spacebar is pressed
    phase = Phase.SHOWING;
    showSequence();
  }

  async function showSequence() {
    stopAutoScan();
    cancelBackScanIfAny();
    phase = Phase.SHOWING;
    speak('Round ' + round);
    await sleep(1800); // wait longer so TTS finishes before sequence
    for (let i = 0; i < sequence.length; i++) {
      const idx = sequence[i];
      flashQuadrant(idx, 480);
      beep(idx, 460);
      await sleep(1060); // slowed by +0.5s (560 -> 1060)
    }
    playerProgress = 0;
    phase = Phase.PLAYER;
    startAutoScan(); // Resume auto-scan in player phase
  }

  function flashQuadrant(idx, dur) {
    const d = typeof dur === 'number' ? dur : 380;
    flashingIndex = idx;
    flashUntil = performance.now() + d;
  }

  function handlePlayerPick(pick) {
    if (phase !== Phase.PLAYER) return;
    flashQuadrant(pick, 300);
    beep(pick, 550);

    if (pick === sequence[playerProgress]) {
      playerProgress += 1;
      if (playerProgress === sequence.length) {
        round += 1;
        sequence.push(randInt(colorCount));
        phase = Phase.SHOWING;
        setTimeout(showSequence, 320);
      }
    } else {
      phase = Phase.GAMEOVER;
      speakGameOverAndReturnToTitle();
    }
  }

  function speakGameOverAndReturnToTitle() {
    speak('Game over');
    setTimeout(() => {
      phase = Phase.TITLE;
      titleHighlight = -1; // No highlight until spacebar is pressed
      flashingIndex = -1;
    }, 1500);
  }

  function exitApp() {
    speak('Exiting game');
    setTimeout(() => {
        // In standalone mode, we just reload or show a message
        window.location.reload();
    }, 800);
  }

  function updateSettingsItems() {
    if (!window.NarbeScanManager) return;
    const s = window.NarbeScanManager.getSettings();
    settingsItems = [
      `Auto Scan: ${s.autoScan ? 'ON' : 'OFF'}`,
      `Speed: ${s.scanInterval/1000}s`,
      'Back'
    ];
  }

  function handleSettingsAction() {
    if (!window.NarbeScanManager) return;
    if (settingsHighlight === 0) {
      // Toggle auto scan
      const s = window.NarbeScanManager.getSettings();
      window.NarbeScanManager.setAutoScan(!s.autoScan);
    } else if (settingsHighlight === 1) {
      // Cycle speed
      window.NarbeScanManager.cycleScanSpeed();
    } else if (settingsHighlight === 2) {
      // Back
      phase = Phase.TITLE;
      titleHighlight = 0; // Reset focus to top
    }
    updateSettingsItems();
    if (phase === Phase.SETTINGS && settingsHighlight < settingsItems.length) {
       speak(settingsItems[settingsHighlight]);
    }
    // Update active auto scan
    if (settingsHighlight === 0 || settingsHighlight === 1) {
       if (window.NarbeScanManager.getSettings().autoScan) {
          startAutoScan();
       } else {
          stopAutoScan();
       }
    }
  }

  window.addEventListener('keydown', (e) => {
    if (e.code === 'Space') e.preventDefault();
    if (e.repeat) return;
    
    // Stop auto-scan on user input
    stopAutoScan();
    
    // Audio unlock is handled globally now
    // if (!audioCtx) initAudio(); ... removed
    
    if (e.code === 'Space') {
      if (!(phase === Phase.PLAYER || phase === Phase.TITLE || phase === Phase.SETTINGS)) return;
      if (!spaceIsDown) {
        spaceIsDown = true;
        spaceDownAt = performance.now();
        cancelBackScanIfAny();
        if (backScanTimer) clearTimeout(backScanTimer);
        backScanTimer = setTimeout(() => {
          if (spaceIsDown && (performance.now() - spaceDownAt >= BACK_HOLD_THRESHOLD)) {
            isBackScanActive = true;
            const interval = window.NarbeScanManager ? window.NarbeScanManager.getScanInterval() : 1500;
            backScanInterval = setInterval(() => { stepBackward(); }, interval);
          }
        }, BACK_HOLD_THRESHOLD);
      }
    }
  });

  window.addEventListener('keyup', (e) => {
    if (e.code === 'Space') {
      e.preventDefault();
      if (!(phase === Phase.PLAYER || phase === Phase.TITLE || phase === Phase.SETTINGS)) { cancelBackScanIfAny(); return; }
      if (isBackScanActive) {
        cancelBackScanIfAny();
      } else {
        const now = performance.now();
        if (now - lastForwardStepAt >= FORWARD_DEBOUNCE) {
          stepForward();
          lastForwardStepAt = now;
        }
      }
      spaceIsDown = false;
      spaceDownAt = 0;
    }

    if (e.code === 'Enter') {
      const now = performance.now();
      if (now - lastReturnAt < RETURN_DEBOUNCE) return;
      lastReturnAt = now;

      if (phase === Phase.TITLE) {
        if (titleHighlight >= 0 && titleHighlight < titleItems.length) {
          const sel = titleItems[titleHighlight];
          if (sel === 'Exit') {
            exitApp();
          } else if (sel === 'Settings') {
            phase = Phase.SETTINGS;
            settingsHighlight = 0;
            updateSettingsItems();
            speak('Settings');
            speak(settingsItems[0]);
          } else {
            colorCount = sel === 'Easy' ? 2 : (sel === 'Medium' ? 3 : 4);
            startNewGame();
          }
        }
        return;
      }

      if (phase === Phase.SETTINGS) {
         if (settingsHighlight >= 0) handleSettingsAction();
         return;
      }

      if (phase === Phase.SHOWING) return;
      if (phase === Phase.GAMEOVER) return;

      if (phase === Phase.PLAYER) {
        if (highlightIndex >= 0 && highlightIndex < colorCount) handlePlayerPick(highlightIndex);
      }
    }
  });

  // Mouse input
  canvas.addEventListener('click', (e) => {
    // Audio unlock is handled globally
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    if (phase === Phase.TITLE) {
      // Check menu button clicks
      for (let i = 0; i < menuBounds.length; i++) {
        const b = menuBounds[i];
        if (x >= b.x && x <= b.x + b.w && y >= b.y && y <= b.y + b.h) {
          const sel = titleItems[i];
          if (sel === 'Exit') {
            exitApp();
          } else if (sel === 'Settings') {
            phase = Phase.SETTINGS;
            settingsHighlight = 0;
            updateSettingsItems();
            speak('Settings');
            speak(settingsItems[0]);
          } else {
            colorCount = sel === 'Easy' ? 2 : (sel === 'Medium' ? 3 : 4);
            startNewGame();
          }
          return;
        }
      }
    } else if (phase === Phase.SETTINGS) {
       for (let i=0; i < menuBounds.length; i++) {
         const b = menuBounds[i];
         if (x >= b.x && x <= b.x + b.w && y >= b.y && y <= b.y + b.h) {
           settingsHighlight = i;
           handleSettingsAction();
           return;
         }
       }
    } else if (phase === Phase.PLAYER) {
      // Check tile clicks
      for (let i = 0; i < tileBounds.length; i++) {
        const b = tileBounds[i];
        if (x >= b.x && x <= b.x + b.w && y >= b.y && y <= b.y + b.h) {
          handlePlayerPick(i);
          return;
        }
      }
    }
  });

  // Touch input for iOS
  canvas.addEventListener('touchstart', (e) => {
    e.preventDefault(); // Prevent scrolling
    // Audio unlock is handled globally
    if (e.touches.length === 0) return;
    const touch = e.touches[0];
    const rect = canvas.getBoundingClientRect();
    const x = touch.clientX - rect.left;
    const y = touch.clientY - rect.top;

    if (phase === Phase.TITLE) {
      // Check menu button touches
      for (let i = 0; i < menuBounds.length; i++) {
        const b = menuBounds[i];
        if (x >= b.x && x <= b.x + b.w && y >= b.y && y <= b.y + b.h) {
          const sel = titleItems[i];
          if (sel === 'Exit') {
            exitApp();
          } else if (sel === 'Settings') {
            phase = Phase.SETTINGS;
            settingsHighlight = 0;
            updateSettingsItems();
            speak('Settings');
            speak(settingsItems[0]);
          } else {
            colorCount = sel === 'Easy' ? 2 : (sel === 'Medium' ? 3 : 4);
            startNewGame();
          }
          return;
        }
      }
    } else if (phase === Phase.SETTINGS) {
       for (let i=0; i < menuBounds.length; i++) {
         const b = menuBounds[i];
         if (x >= b.x && x <= b.x + b.w && y >= b.y && y <= b.y + b.h) {
           settingsHighlight = i;
           handleSettingsAction();
           return;
         }
       }
    } else if (phase === Phase.PLAYER) {
      // Check tile touches
      for (let i = 0; i < tileBounds.length; i++) {
        const b = tileBounds[i];
        if (x >= b.x && x <= b.x + b.w && y >= b.y && y <= b.y + b.h) {
          handlePlayerPick(i);
          return;
        }
      }
    }
  });

  function cancelBackScanIfAny() {
    if (backScanTimer) { clearTimeout(backScanTimer); backScanTimer = null; }
    if (backScanInterval) { clearInterval(backScanInterval); backScanInterval = null; }
    isBackScanActive = false;
  }

  function stepForward() {
    if (phase === Phase.PLAYER) {
      if (highlightIndex === -1) {
        highlightIndex = 0; // First press: go from no highlight to first button
      } else {
        highlightIndex = (highlightIndex + 1) % colorCount;
      }
    } else if (phase === Phase.TITLE) {
      if (titleHighlight === -1) {
        titleHighlight = 0; // First press: go from no highlight to first menu item
      } else {
        titleHighlight = (titleHighlight + 1) % titleItems.length;
      }
      speak(titleItems[titleHighlight]);
    } else if (phase === Phase.SETTINGS) {
      settingsHighlight = (settingsHighlight + 1) % settingsItems.length;
      speak(settingsItems[settingsHighlight]);
    }
  }

  function stepBackward() {
    if (phase === Phase.PLAYER) {
      if (highlightIndex === 0) {
        highlightIndex = -1; // Go back to no highlight
      } else if (highlightIndex === -1) {
        highlightIndex = colorCount - 1; // Wrap to last button
      } else {
        highlightIndex = (highlightIndex - 1 + colorCount) % colorCount;
      }
    } else if (phase === Phase.TITLE) {
      if (titleHighlight === 0) {
        titleHighlight = -1; // Go back to no highlight
      } else if (titleHighlight === -1) {
        titleHighlight = titleItems.length - 1; // Wrap to last menu item
      } else {
        titleHighlight = (titleHighlight - 1 + titleItems.length) % titleItems.length;
      }
      if (titleHighlight >= 0) {
        speak(titleItems[titleHighlight]);
      }
      speak(titleItems[titleHighlight]);
    } else if (phase === Phase.SETTINGS) {
      settingsHighlight = (settingsHighlight - 1 + settingsItems.length) % settingsItems.length;
      speak(settingsItems[settingsHighlight]);
    }
  }

  // ====== Render ======
  function draw() {
    try {
      const rect = canvas.getBoundingClientRect();
      const w = Math.max(1, Math.floor(rect.width || canvas.width / DPR || window.innerWidth || 800));
      const h = Math.max(1, Math.floor(rect.height || canvas.height / DPR || window.innerHeight || 600));

      // Clear
      ctx.fillStyle = BG;
      ctx.fillRect(0, 0, w, h);

      // Title / Score
      ctx.fillStyle = '#e5e7eb';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      ctx.font = '700 28px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';

      if (phase === Phase.TITLE) {
        // Title
        ctx.fillText('Benny Says', w/2, 24);

        // Big menu buttons
        menuBounds = [];
        const mx = 20; const mw = w - 40;
        const startY = 90;
        const rows = titleItems.length;
        const btnH = Math.max(72, Math.floor((h - startY - 120) / (rows + 0.3)));
        const gap = Math.max(14, Math.floor(btnH * 0.16));
        for (let i = 0; i < rows; i++) {
          const y = startY + i * (btnH + gap);
          const isSel = (i === titleHighlight);
          const radius = 18;
          
          // Store bounds for mouse detection
          menuBounds.push({x: mx, y: y, w: mw, h: btnH});
          
          ctx.fillStyle = MENU_COLORS[i];
          roundRect(mx, y, mw, btnH, radius);
          ctx.fill();
          if (isSel) {
            ctx.save();
            ctx.lineWidth = 8; ctx.strokeStyle = 'rgba(255,255,255,0.98)';
            ctx.shadowBlur = 22; ctx.shadowColor = 'rgba(255,255,255,0.9)';
            roundRect(mx, y, mw, btnH, radius);
            ctx.stroke();
            ctx.restore();
          }
          ctx.fillStyle = '#0b2239';
          ctx.font = '800 24px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
          ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
          ctx.fillText(titleItems[i], mx + mw/2, y + btnH/2);
        }

        ctx.font = '400 14px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillStyle = '#e5e7eb';
        ctx.fillText('Space = scan, Return = select, Click = direct select', w/2, startY + rows*(btnH+gap) + 8);

      } else if (phase === Phase.SETTINGS) {
        ctx.fillText('Settings', w/2, 24);

        menuBounds = [];
        const mx = 20; const mw = w - 40;
        const startY = 80;
        const rows = settingsItems.length;
        const btnH = 60;
        const gap = 16;
        for (let i = 0; i < rows; i++) {
          const y = startY + i * (btnH + gap);
          const isSel = (i === settingsHighlight);
          
          menuBounds.push({x: mx, y: y, w: mw, h: btnH});
          
          ctx.fillStyle = '#334155'; // Slate 700
          roundRect(mx, y, mw, btnH, 12);
          ctx.fill();
          if (isSel) {
            ctx.save();
            ctx.lineWidth = 4; ctx.strokeStyle = '#38bdf8'; // Sky 400
            ctx.shadowBlur = 10; ctx.shadowColor = '#0ea5e9';
            roundRect(mx, y, mw, btnH, 12);
            ctx.stroke();
            ctx.restore();
          }
          ctx.fillStyle = '#f8fafc';
          ctx.font = '700 20px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
          ctx.textAlign = 'left'; ctx.textBaseline = 'middle';
          ctx.fillText(settingsItems[i], mx + 24, y + btnH/2);
        }
      } else if (phase === Phase.GAMEOVER) {
        ctx.fillText('Game Over', w/2, 24);
        ctx.font = '400 16px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
        ctx.fillText('Returning to menu...', w/2, 60);

      } else {
        ctx.fillText('Round ' + round, w/2, 24);

        // Gameplay tiles (fill screen based on colorCount)
        tileBounds = [];
        const pad = 16;
        if (colorCount === 2) {
          const gap = 12; const bx = pad; const bw = (w - pad*2 - gap) / 2;
          const by = 64; const bh = h - by - pad;
          drawTile(0, {x: bx, y: by, w: bw, h: bh});
          drawTile(1, {x: bx + bw + gap, y: by, w: bw, h: bh});
        } else if (colorCount === 3) {
          const gap = 12; const bw = (w - pad*2 - gap*2) / 3;
          const by = 64; const bh = h - by - pad;
          drawTile(0, {x: pad, y: by, w: bw, h: bh});
          drawTile(1, {x: pad + bw + gap, y: by, w: bw, h: bh});
          drawTile(2, {x: pad + (bw + gap) * 2, y: by, w: bw, h: bh});
        } else {
          const gap = 12; const by = 64;
          const bh = (h - by - pad - gap) / 2; const bw = (w - pad*2 - gap) / 2;
          drawTile(0, {x: pad, y: by, w: bw, h: bh});
          drawTile(1, {x: pad + bw + gap, y: by, w: bw, h: bh});
          drawTile(2, {x: pad, y: by + bh + gap, w: bw, h: bh});
          drawTile(3, {x: pad + bw + gap, y: by + bh + gap, w: bw, h: bh});
        }
      }

      if (flashingIndex !== -1 && performance.now() >= flashUntil) {
        flashingIndex = -1;
      }

    } catch (err) {
      // Visible error message on canvas
      ctx.fillStyle = '#111827'; ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = '#ef4444';
      ctx.font = '600 16px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
      ctx.textAlign = 'left'; ctx.textBaseline = 'top';
      ctx.fillText('Render error: ' + (err && err.message ? err.message : String(err)), 12, 12);
    }
    requestAnimationFrame(draw);
  }

  function drawTile(i, q) {
    // Store bounds for mouse detection
    tileBounds.push({x: q.x, y: q.y, w: q.w, h: q.h});
    
    const now = performance.now();
    const isFlash = (i === flashingIndex) && (now < flashUntil);
    const color = COLORS[i];

    ctx.fillStyle = isFlash ? lighten(color, FLASH_LIGHTEN) : color;
    roundRect(q.x, q.y, q.w, q.h, 28); ctx.fill();

    if (phase === Phase.PLAYER && highlightIndex === i) {
      ctx.save();
      ctx.lineWidth = 12; ctx.strokeStyle = 'rgba(255,255,255,0.98)';
      ctx.shadowBlur = 28; ctx.shadowColor = 'rgba(255,255,255,0.95)';
      roundRect(q.x, q.y, q.w, q.h, 30); ctx.stroke();
      ctx.restore();
    }

    ctx.fillStyle = '#0b2239';
    ctx.font = '800 28px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.fillText(NAMES[i], q.x + q.w/2, q.y + q.h/2);
  }

  function roundRect(x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
  }

  function lighten(hex, amt) {
    const a = typeof amt === 'number' ? amt : 0.3;
    const c = hex.replace('#','');
    const r = parseInt(c.slice(0,2),16);
    const g = parseInt(c.slice(2,4),16);
    const b = parseInt(c.slice(4,6),16);
    const lr = Math.min(255, Math.floor(r + (255 - r) * a));
    const lg = Math.min(255, Math.floor(g + (255 - g) * a));
    const lb = Math.min(255, Math.floor(b + (255 - b) * a));
    return '#' + lr.toString(16).padStart(2,'0') + lg.toString(16).padStart(2,'0') + lb.toString(16).padStart(2,'0');
  }

  // Check NarbeScanManager on load for auto-scan
  window.addEventListener('load', () => {
    if (window.NarbeScanManager) {
      if (window.NarbeScanManager.getSettings().autoScan) {
        startAutoScan();
      }
      // Listen for changes
      window.NarbeScanManager.subscribe((s) => {
         updateSettingsItems();
         if (s.autoScan) {
             startAutoScan();
         } else {
             stopAutoScan();
         }
      });
    }
  });

  // Start
  requestAnimationFrame(draw);
  </script>
</body>
</html>