<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Benny Says</title>
  <style>
    html, body { margin: 0; height: 100%; background: #0f172a; color: #e5e7eb; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    #wrap { position: relative; width: 100%; height: 100%; }
    canvas { display: block; width: 100%; height: 100%; background: #0b2239; cursor: pointer; }
    .hint { position: absolute; left: 12px; bottom: 12px; font-size: 12px; opacity: .7; }
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="game"></canvas>
    <div class="hint">Space = scan (hold 3s = auto-back every 1.5s). Return = select. Click = direct select.</div>
  </div>

  <!-- Include shared voice manager -->
  <script src="../../../shared/voice-manager.js"></script>
  
  <script>
  // ====== Constants ======
  const BACK_HOLD_THRESHOLD = 3000;   // ms to engage back-scan
  const BACK_STEP_INTERVAL  = 1500;   // ms per backward step
  const FORWARD_DEBOUNCE    = 160;    // ms debounce for space release forward step
  const RETURN_DEBOUNCE     = 160;    // ms debounce for return release

  const COLORS = ['#ff5c00', '#5bb0ff', '#39d353', '#a78bfa'];
  const NAMES  = ['Orange','Blue','Green','Purple'];
  const MENU_ITEMS  = ['Easy','Medium','Hard','Exit'];
  const MENU_COLORS = ['#60a5fa', '#34d399', '#f59e0b', '#ef4444'];

  const HILITE = '#ffffff';
  const BG = '#0b2239';
  const FLASH_LIGHTEN = 0.75;

  // ====== Canvas setup ======
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  let DPR = 1;
  function resize() {
    DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const rect = canvas.getBoundingClientRect();
    const cssW = Math.max(1, Math.floor(rect.width || window.innerWidth || 800));
    const cssH = Math.max(1, Math.floor(rect.height || window.innerHeight || 600));
    canvas.width = cssW * DPR;
    canvas.height = cssH * DPR;
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
  }
  window.addEventListener('resize', resize);
  resize();

  // ====== Audio ======
  let audioCtx = null;
  let masterGain = null;
  let audioUnlocked = false;

  function initAudio() {
    if (audioCtx || audioUnlocked) return;
    try {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      masterGain = audioCtx.createGain();
      masterGain.gain.value = 0.5; // Medium
      masterGain.connect(audioCtx.destination);
      audioUnlocked = true;
      console.log('Audio unlocked for BENNYSAYS');
    } catch (e) {
      console.warn('Failed to create audio context:', e);
    }
  }

  const TONES = [329.63, 261.63, 392.00, 523.25]; // E4, C4, G4, C5

  function beep(idx, dur) {
    if (!audioCtx) {
      initAudio();
      if (!audioCtx) return; // Still failed, give up
    }
    
    const d = typeof dur === 'number' ? dur : 520;
    try {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = 'sine';
      osc.frequency.value = TONES[idx % TONES.length];
      gain.gain.value = 0.001;
      osc.connect(gain);
      gain.connect(masterGain);
      const now = audioCtx.currentTime;
      gain.gain.setValueAtTime(0.001, now);
      gain.gain.linearRampToValueAtTime(1.0, now + 0.02);
      gain.gain.linearRampToValueAtTime(0.001, now + d/1000);
      osc.start();
      osc.stop(now + d/1000 + 0.02);
    } catch (e) { /* ignore */ }
  }

  // ====== State ======
  const Phase = { TITLE: 'title', SHOWING: 'showing', PLAYER: 'player', GAMEOVER: 'gameover' };
  let phase = Phase.TITLE;
  let sequence = [];
  let playerProgress = 0;
  let round = 0;

  // difficulty
  let colorCount = 4; // set by menu

  // indices
  let highlightIndex = -1; // gameplay scan index -1 (no highlight) then 0..colorCount-1
  const titleItems = MENU_ITEMS.slice();
  let titleHighlight = -1; // -1 (no highlight) then 0..3

  // timers/flags
  let spaceIsDown = false;
  let spaceDownAt = 0;
  let backScanTimer = null;
  let backScanInterval = null;
  let isBackScanActive = false;
  let lastForwardStepAt = 0;
  let lastReturnAt = 0;

  // visuals
  let flashingIndex = -1;
  let flashUntil = 0;

  // Store tile bounds for mouse detection
  let tileBounds = [];
  let menuBounds = [];

  // ====== Utilities ======
  function sleep(ms) { return new Promise(res => setTimeout(res, ms)); }
  function randInt(n) { return Math.floor(Math.random() * n); }
  function speak(text) {
    if (window.NarbeVoiceManager) {
      window.NarbeVoiceManager.speak(text);
    }
  }

  // Robust exit helper: communicates with parent to focus back button
  function exitApp(){
    try{
      // Try to message parent window to focus the back button
      if (window.parent && window.parent !== window) {
        window.parent.postMessage({ action: 'focusBackButton' }, '*');
      }
      // Navigate to parent directory (Access-Hub root)
      location.href = '../index.html';
    }catch(err){
      // Fallback: try relative navigation
      try{
        window.location.replace('../index.html');
      }catch(_){
        // Last resort: go up one level
        window.location.href = '..';
      }
    }
  }

  // ====== Game flow ======
  function startNewGame() {
    sequence = [randInt(colorCount)];
    playerProgress = 0;
    round = 1;
    highlightIndex = -1; // Start with no highlight until spacebar is pressed
    phase = Phase.SHOWING;
    showSequence();
  }

  async function showSequence() {
    cancelBackScanIfAny();
    phase = Phase.SHOWING;
    speak('Round ' + round);
    await sleep(1800); // wait longer so TTS finishes before sequence
    for (let i = 0; i < sequence.length; i++) {
      const idx = sequence[i];
      flashQuadrant(idx, 480);
      beep(idx, 460);
      await sleep(1060); // slowed by +0.5s (560 -> 1060)
    }
    playerProgress = 0;
    phase = Phase.PLAYER;
  }

  function flashQuadrant(idx, dur) {
    const d = typeof dur === 'number' ? dur : 380;
    flashingIndex = idx;
    flashUntil = performance.now() + d;
  }

  function handlePlayerPick(pick) {
    if (phase !== Phase.PLAYER) return;
    flashQuadrant(pick, 300);
    beep(pick, 550);

    if (pick === sequence[playerProgress]) {
      playerProgress += 1;
      if (playerProgress === sequence.length) {
        round += 1;
        sequence.push(randInt(colorCount));
        phase = Phase.SHOWING;
        setTimeout(showSequence, 320);
      }
    } else {
      phase = Phase.GAMEOVER;
      speakGameOverAndReturnToTitle();
    }
  }

  function speakGameOverAndReturnToTitle() {
    speak('Game over');
    setTimeout(() => {
      phase = Phase.TITLE;
      titleHighlight = -1; // No highlight until spacebar is pressed
      flashingIndex = -1;
    }, 1500);
  }

  // ====== Input handling ======
  window.addEventListener('keydown', (e) => {
    if (e.code === 'Space') e.preventDefault();
    if (e.repeat) return;
    
    // Initialize and resume audio on first user interaction
    if (!audioCtx) initAudio();
    if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();

    if (e.code === 'Space') {
      if (phase === Phase.PLAYER || phase === Phase.TITLE) {
        if (!spaceIsDown) {
          spaceIsDown = true;
          spaceDownAt = performance.now();
          backScanTimer = setTimeout(() => {
            if (spaceIsDown && (performance.now() - spaceDownAt >= BACK_HOLD_THRESHOLD)) {
              isBackScanActive = true;
              backScanInterval = setInterval(() => { stepBackward(); }, BACK_STEP_INTERVAL);
            }
          }, BACK_HOLD_THRESHOLD);
        }
      }
    }
  });

  window.addEventListener('keyup', (e) => {
    if (e.code === 'Space') {
      e.preventDefault();
      if (!(phase === Phase.PLAYER || phase === Phase.TITLE)) { cancelBackScanIfAny(); return; }
      if (isBackScanActive) {
        cancelBackScanIfAny();
      } else {
        const now = performance.now();
        if (now - lastForwardStepAt >= FORWARD_DEBOUNCE) {
          stepForward();
          lastForwardStepAt = now;
        }
      }
      spaceIsDown = false;
      spaceDownAt = 0;
    }

    if (e.code === 'Enter') {
      const now = performance.now();
      if (now - lastReturnAt < RETURN_DEBOUNCE) return;
      lastReturnAt = now;

      if (phase === Phase.TITLE) {
        if (titleHighlight >= 0 && titleHighlight < titleItems.length) {
          const sel = titleItems[titleHighlight];
          if (sel === 'Exit') {
            exitApp();
          } else {
            colorCount = sel === 'Easy' ? 2 : (sel === 'Medium' ? 3 : 4);
            startNewGame();
          }
        }
        return;
      }

      if (phase === Phase.SHOWING) return;
      if (phase === Phase.GAMEOVER) return;

      if (phase === Phase.PLAYER) {
        if (highlightIndex >= 0 && highlightIndex < colorCount) handlePlayerPick(highlightIndex);
      }
    }
  });

  // Mouse input
  canvas.addEventListener('click', (e) => {
    // Initialize and resume audio on first user interaction
    if (!audioCtx) initAudio();
    if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
    
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    if (phase === Phase.TITLE) {
      // Check menu button clicks
      for (let i = 0; i < menuBounds.length; i++) {
        const b = menuBounds[i];
        if (x >= b.x && x <= b.x + b.w && y >= b.y && y <= b.y + b.h) {
          const sel = titleItems[i];
          if (sel === 'Exit') {
            exitApp();
          } else {
            colorCount = sel === 'Easy' ? 2 : (sel === 'Medium' ? 3 : 4);
            startNewGame();
          }
          return;
        }
      }
    } else if (phase === Phase.PLAYER) {
      // Check tile clicks
      for (let i = 0; i < tileBounds.length; i++) {
        const b = tileBounds[i];
        if (x >= b.x && x <= b.x + b.w && y >= b.y && y <= b.y + b.h) {
          handlePlayerPick(i);
          return;
        }
      }
    }
  });

  // Touch input for iOS
  canvas.addEventListener('touchstart', (e) => {
    e.preventDefault(); // Prevent scrolling
    
    // Initialize and resume audio on first user interaction
    if (!audioCtx) initAudio();
    if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
    
    if (e.touches.length === 0) return;
    const touch = e.touches[0];
    const rect = canvas.getBoundingClientRect();
    const x = touch.clientX - rect.left;
    const y = touch.clientY - rect.top;

    if (phase === Phase.TITLE) {
      // Check menu button touches
      for (let i = 0; i < menuBounds.length; i++) {
        const b = menuBounds[i];
        if (x >= b.x && x <= b.x + b.w && y >= b.y && y <= b.y + b.h) {
          const sel = titleItems[i];
          if (sel === 'Exit') {
            exitApp();
          } else {
            colorCount = sel === 'Easy' ? 2 : (sel === 'Medium' ? 3 : 4);
            startNewGame();
          }
          return;
        }
      }
    } else if (phase === Phase.PLAYER) {
      // Check tile touches
      for (let i = 0; i < tileBounds.length; i++) {
        const b = tileBounds[i];
        if (x >= b.x && x <= b.x + b.w && y >= b.y && y <= b.y + b.h) {
          handlePlayerPick(i);
          return;
        }
      }
    }
  });

  function cancelBackScanIfAny() {
    if (backScanTimer) { clearTimeout(backScanTimer); backScanTimer = null; }
    if (backScanInterval) { clearInterval(backScanInterval); backScanInterval = null; }
    isBackScanActive = false;
  }

  function stepForward() {
    if (phase === Phase.PLAYER) {
      if (highlightIndex === -1) {
        highlightIndex = 0; // First press: go from no highlight to first button
      } else {
        highlightIndex = (highlightIndex + 1) % colorCount;
      }
    } else if (phase === Phase.TITLE) {
      if (titleHighlight === -1) {
        titleHighlight = 0; // First press: go from no highlight to first menu item
      } else {
        titleHighlight = (titleHighlight + 1) % titleItems.length;
      }
      speak(titleItems[titleHighlight]);
    }
  }

  function stepBackward() {
    if (phase === Phase.PLAYER) {
      if (highlightIndex === 0) {
        highlightIndex = -1; // Go back to no highlight
      } else if (highlightIndex === -1) {
        highlightIndex = colorCount - 1; // Wrap to last button
      } else {
        highlightIndex = (highlightIndex - 1 + colorCount) % colorCount;
      }
    } else if (phase === Phase.TITLE) {
      if (titleHighlight === 0) {
        titleHighlight = -1; // Go back to no highlight
      } else if (titleHighlight === -1) {
        titleHighlight = titleItems.length - 1; // Wrap to last menu item
      } else {
        titleHighlight = (titleHighlight - 1 + titleItems.length) % titleItems.length;
      }
      if (titleHighlight >= 0) {
        speak(titleItems[titleHighlight]);
      }
      speak(titleItems[titleHighlight]);
    }
  }

  // ====== Render ======
  function draw() {
    try {
      const rect = canvas.getBoundingClientRect();
      const w = Math.max(1, Math.floor(rect.width || canvas.width / DPR || window.innerWidth || 800));
      const h = Math.max(1, Math.floor(rect.height || canvas.height / DPR || window.innerHeight || 600));

      // Clear
      ctx.fillStyle = BG;
      ctx.fillRect(0, 0, w, h);

      // Title / Score
      ctx.fillStyle = '#e5e7eb';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      ctx.font = '700 28px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';

      if (phase === Phase.TITLE) {
        // Title
        ctx.fillText('Benny Says', w/2, 24);

        // Big menu buttons
        menuBounds = [];
        const mx = 20; const mw = w - 40;
        const startY = 90;
        const rows = titleItems.length;
        const btnH = Math.max(72, Math.floor((h - startY - 120) / (rows + 0.3)));
        const gap = Math.max(14, Math.floor(btnH * 0.16));
        for (let i = 0; i < rows; i++) {
          const y = startY + i * (btnH + gap);
          const isSel = (i === titleHighlight);
          const radius = 18;
          
          // Store bounds for mouse detection
          menuBounds.push({x: mx, y: y, w: mw, h: btnH});
          
          ctx.fillStyle = MENU_COLORS[i];
          roundRect(mx, y, mw, btnH, radius);
          ctx.fill();
          if (isSel) {
            ctx.save();
            ctx.lineWidth = 8; ctx.strokeStyle = 'rgba(255,255,255,0.98)';
            ctx.shadowBlur = 22; ctx.shadowColor = 'rgba(255,255,255,0.9)';
            roundRect(mx, y, mw, btnH, radius);
            ctx.stroke();
            ctx.restore();
          }
          ctx.fillStyle = '#0b2239';
          ctx.font = '800 24px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
          ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
          ctx.fillText(titleItems[i], mx + mw/2, y + btnH/2);
        }

        ctx.font = '400 14px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillStyle = '#e5e7eb';
        ctx.fillText('Space = scan, Return = select, Click = direct select', w/2, startY + rows*(btnH+gap) + 8);

      } else if (phase === Phase.GAMEOVER) {
        ctx.fillText('Game Over', w/2, 24);
        ctx.font = '400 16px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
        ctx.fillText('Returning to menu...', w/2, 60);

      } else {
        ctx.fillText('Round ' + round, w/2, 24);

        // Gameplay tiles (fill screen based on colorCount)
        tileBounds = [];
        const pad = 16;
        if (colorCount === 2) {
          const gap = 12; const bx = pad; const bw = (w - pad*2 - gap) / 2;
          const by = 64; const bh = h - by - pad;
          drawTile(0, {x: bx, y: by, w: bw, h: bh});
          drawTile(1, {x: bx + bw + gap, y: by, w: bw, h: bh});
        } else if (colorCount === 3) {
          const gap = 12; const bw = (w - pad*2 - gap*2) / 3;
          const by = 64; const bh = h - by - pad;
          drawTile(0, {x: pad, y: by, w: bw, h: bh});
          drawTile(1, {x: pad + bw + gap, y: by, w: bw, h: bh});
          drawTile(2, {x: pad + (bw + gap) * 2, y: by, w: bw, h: bh});
        } else {
          const gap = 12; const by = 64;
          const bh = (h - by - pad - gap) / 2; const bw = (w - pad*2 - gap) / 2;
          drawTile(0, {x: pad, y: by, w: bw, h: bh});
          drawTile(1, {x: pad + bw + gap, y: by, w: bw, h: bh});
          drawTile(2, {x: pad, y: by + bh + gap, w: bw, h: bh});
          drawTile(3, {x: pad + bw + gap, y: by + bh + gap, w: bw, h: bh});
        }
      }

      if (flashingIndex !== -1 && performance.now() >= flashUntil) {
        flashingIndex = -1;
      }

    } catch (err) {
      // Visible error message on canvas
      ctx.fillStyle = '#111827'; ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = '#ef4444';
      ctx.font = '600 16px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
      ctx.textAlign = 'left'; ctx.textBaseline = 'top';
      ctx.fillText('Render error: ' + (err && err.message ? err.message : String(err)), 12, 12);
    }
    requestAnimationFrame(draw);
  }

  function drawTile(i, q) {
    // Store bounds for mouse detection
    tileBounds.push({x: q.x, y: q.y, w: q.w, h: q.h});
    
    const now = performance.now();
    const isFlash = (i === flashingIndex) && (now < flashUntil);
    const color = COLORS[i];

    ctx.fillStyle = isFlash ? lighten(color, FLASH_LIGHTEN) : color;
    roundRect(q.x, q.y, q.w, q.h, 28); ctx.fill();

    if (phase === Phase.PLAYER && highlightIndex === i) {
      ctx.save();
      ctx.lineWidth = 12; ctx.strokeStyle = 'rgba(255,255,255,0.98)';
      ctx.shadowBlur = 28; ctx.shadowColor = 'rgba(255,255,255,0.95)';
      roundRect(q.x, q.y, q.w, q.h, 30); ctx.stroke();
      ctx.restore();
    }

    ctx.fillStyle = '#0b2239';
    ctx.font = '800 28px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.fillText(NAMES[i], q.x + q.w/2, q.y + q.h/2);
  }

  function roundRect(x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
  }

  function lighten(hex, amt) {
    const a = typeof amt === 'number' ? amt : 0.3;
    const c = hex.replace('#','');
    const r = parseInt(c.slice(0,2),16);
    const g = parseInt(c.slice(2,4),16);
    const b = parseInt(c.slice(4,6),16);
    const lr = Math.min(255, Math.floor(r + (255 - r) * a));
    const lg = Math.min(255, Math.floor(g + (255 - g) * a));
    const lb = Math.min(255, Math.floor(b + (255 - b) * a));
    return '#' + lr.toString(16).padStart(2,'0') + lg.toString(16).padStart(2,'0') + lb.toString(16).padStart(2,'0');
  }

  // Start
  requestAnimationFrame(draw);
  </script>
</body>
</html>
