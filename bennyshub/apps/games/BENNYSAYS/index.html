<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Benny Says</title>
  <style>
    html, body { margin: 0; height: 100%; background: #0f172a; color: #e5e7eb; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    #wrap { position: relative; width: 100%; height: 100%; }
    canvas { display: block; width: 100%; height: 100%; background: #0b2239; cursor: pointer; }
    .hint { position: absolute; left: 12px; bottom: 12px; font-size: 12px; opacity: .7; }
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="game"></canvas>
    <div class="hint">Space = scan (hold 3s = auto-back every 1.5s). Return = select. Click = direct select.</div>
  </div>

  <!-- Include shared voice manager -->
  <script src="../../../shared/voice-manager.js"></script>
  <!-- Fix iOS Audio not playing -->
  <script src="../../../shared/ios-audio-fix.js"></script>
  <script src="../../../shared/scan-manager.js"></script>
  
  <script>
  // ====== Constants ======
  const BACK_HOLD_THRESHOLD = 3000;   // ms to engage back-scan
  // BACK_STEP_INTERVAL will be retrieved from NarbeScanManager
  const FORWARD_DEBOUNCE    = 160;    // ms debounce for space release forward step
  const RETURN_DEBOUNCE     = 160;    // ms debounce for return release

  const COLORS = ['#ff5c00', '#5bb0ff', '#39d353', '#a78bfa'];
  const NAMES  = ['Orange','Blue','Green','Purple'];
  
  const MAIN_MENU_ITEMS = ['Play Game', 'Settings', 'Exit Game'];
  const MAIN_COLORS = ['#3bb273', '#8b5cf6', '#ef4444', '#f97316']; 
  
  const DIFFICULTY_ITEMS = ['Easy', 'Medium', 'Hard', 'Back'];
  const DIFFICULTY_COLORS = ['#60a5fa', '#34d399', '#f59e0b', '#64748b']; 

  const HILITE = '#ffffff';
  const BG = '#0b2239';
  const FLASH_LIGHTEN = 0.75;

  // ====== Canvas setup ======
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  let DPR = 1;
  function resize() {
    DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const rect = canvas.getBoundingClientRect();
    const cssW = Math.max(1, Math.floor(rect.width || window.innerWidth || 800));
    const cssH = Math.max(1, Math.floor(rect.height || window.innerHeight || 600));
    canvas.width = cssW * DPR;
    canvas.height = cssH * DPR;
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
  }
  window.addEventListener('resize', resize);
  resize();

  // ====== Audio ======
  const TONES = [329.63, 261.63, 392.00, 523.25]; // E4, C4, G4, C5
  let audioElements = [];
  let audioUnlocked = false;

  // Generate tone audio buffers as data URLs for iOS compatibility
  function generateToneDataURL(frequency, duration = 0.5) {
    const sampleRate = 44100;
    const numSamples = Math.floor(sampleRate * duration);
    const channels = 1;
    const bitsPerSample = 16;
    
    // WAV file structure
    const wavHeader = new ArrayBuffer(44);
    const view = new DataView(wavHeader);
    
    // "RIFF" chunk descriptor
    view.setUint32(0, 0x52494646, false); // "RIFF"
    view.setUint32(4, 36 + numSamples * 2, true); // file size - 8
    view.setUint32(8, 0x57415645, false); // "WAVE"
    
    // "fmt " sub-chunk
    view.setUint32(12, 0x666d7420, false); // "fmt "
    view.setUint32(16, 16, true); // subchunk size
    view.setUint16(20, 1, true); // audio format (1 = PCM)
    view.setUint16(22, channels, true);
    view.setUint32(24, sampleRate, true);
    view.setUint32(28, sampleRate * channels * bitsPerSample / 8, true); // byte rate
    view.setUint16(32, channels * bitsPerSample / 8, true); // block align
    view.setUint16(34, bitsPerSample, true);
    
    // "data" sub-chunk
    view.setUint32(36, 0x64617461, false); // "data"
    view.setUint32(40, numSamples * 2, true); // data size
    
    // Generate sine wave samples
    const samples = new Int16Array(numSamples);
    for (let i = 0; i < numSamples; i++) {
      const t = i / sampleRate;
      const envelope = Math.min(1, Math.min(t * 50, (duration - t) * 50)); // fade in/out
      samples[i] = Math.floor(envelope * Math.sin(2 * Math.PI * frequency * t) * 32767 * 0.3);
    }
    
    // Combine header and samples
    const wavFile = new Uint8Array(44 + numSamples * 2);
    wavFile.set(new Uint8Array(wavHeader), 0);
    wavFile.set(new Uint8Array(samples.buffer), 44);
    
    // Create blob and data URL
    const blob = new Blob([wavFile], { type: 'audio/wav' });
    return URL.createObjectURL(blob);
  }

  // Pre-generate all tone audio elements
  function initAudio() {
    if (audioElements.length > 0) return;
    
    TONES.forEach((freq, idx) => {
      const audio = new Audio(generateToneDataURL(freq, 0.52));
      audio.volume = 0.5;
      audio.preload = 'auto';
      audioElements.push(audio);
    });
    
    console.log('Audio elements initialized');
  }

  async function unlockAudio() {
    // If ios-audio-fix.js is loaded, it handles the global unlock on capture phase.
    // We shouldn't try to play/speak here to avoid conflicts (AudioSession interruptions).
    if (audioUnlocked) return true;

    try {
      // Just ensure elements are created
      if (audioElements.length === 0) {
        initAudio();
      }
      
      // Removed: Aggressive audio.play() and 'OK' speech. 
      // Rely on the current user gesture (click/touch) to authorize the subsequent speak() calls directly.

      audioUnlocked = true;
      console.log('Audio init only (passive unlock)');
      return true;
    } catch (e) {
      console.warn("unlockAudio failed:", e);
      return false;
    }
  }

  function beep(idx, dur) {
    if (!isAudioActive) return;
    
    const audio = audioElements[idx % audioElements.length];
    if (!audio) return;
    
    try {
      audio.currentTime = 0;
      audio.play().catch(e => console.warn('Beep play failed:', e));
    } catch (e) {
      console.warn('Beep error:', e);
    }
  }

  // ====== State ======
  const Phase = { MAIN: 'main', DIFFICULTY: 'difficulty', SETTINGS: 'settings', SHOWING: 'showing', PLAYER: 'player', GAMEOVER: 'gameover' };
  let phase = Phase.MAIN;
  let sequence = [];
  let playerProgress = 0;
  let round = 0;

  // difficulty
  let colorCount = 4; // set by menu

  // indices
  let highlightIndex = -1; // gameplay scan index -1 (no highlight) then 0..colorCount-1
  
  // Main Menu
  let mainHighlight = -1;

  // Difficulty Menu
  let diffHighlight = -1;
  
  // Settings menu state
  let settingsItems = [];
  let settingsHighlight = -1;
  let isAudioActive = true;

  // timers/flags
  let spaceIsDown = false;
  let spaceDownAt = 0;
  let backScanTimer = null;
  let backScanInterval = null;
  let isBackScanActive = false;
  let lastForwardStepAt = 0;
  let lastReturnAt = 0;

  // Auto Scan Logic
  let autoScanTimer = null;

  function startAutoScan() {
    stopAutoScan();
    // Only run if NarbeScanManager says autoScan is on
    if (window.NarbeScanManager && window.NarbeScanManager.getSettings().autoScan) {
       const scanSpeed = window.NarbeScanManager.getScanInterval();
       autoScanTimer = setInterval(() => { stepForward(); }, scanSpeed);
    }
  }

  function stopAutoScan() {
    if (autoScanTimer) {
      clearInterval(autoScanTimer);
      autoScanTimer = null;
    }
  }

  // visuals
  let flashingIndex = -1;
  let flashUntil = 0;

  // Store tile bounds for mouse detection
  let tileBounds = [];
  let menuBounds = [];

  // ====== Utilities ======
  function sleep(ms) { return new Promise(res => setTimeout(res, ms)); }
  function randInt(n) { return Math.floor(Math.random() * n); }

  const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || 
                (navigator.userAgent.includes('Mac') && 'ontouchend' in document) ||
                (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);

  console.log('iOS detection:', isIOS, 'UserAgent:', navigator.userAgent, 'Platform:', navigator.platform);

  function speak(text) {
    if (!text) return;

    // Check if TTS is enabled globally
    if (!isTTSEnabled()) {
        console.log('TTS disabled, skipping speech:', text);
        return;
    }

    console.log('Attempting to speak:', text, 'isIOS:', isIOS);

    // iOS requires immediate speech synthesis in user gesture
    if (isIOS && window.speechSynthesis) {
      console.log('Using iOS direct speech synthesis');
      window.speechSynthesis.cancel(); // Cancel previous
      
      const utterance = new SpeechSynthesisUtterance(text);
      
      // CRITICAL FIX: Bind to window to prevent Garbage Collection on iOS
      window._iosUtterance = utterance;
      
      // Attempt to select a valid voice
      const voices = window.speechSynthesis.getVoices();
      if (voices.length > 0) {
         // Try to find Samantha or Daniel (high quality iOS voices) or any English
         const preferred = voices.find(v => v.name === 'Samantha') || 
                           voices.find(v => v.name === 'Daniel') || 
                           voices.find(v => v.lang.startsWith('en'));
         if (preferred) {
             utterance.voice = preferred;
             console.log('Using iOS Voice:', preferred.name);
         }
      }

      utterance.volume = 1.0; // Max volume
      utterance.rate = 1.0;
      utterance.pitch = 1.0;
      
      utterance.onstart = () => console.log('iOS speech started');
      utterance.onend = () => { console.log('iOS speech ended'); window._iosUtterance = null; };
      utterance.onerror = (e) => { console.error('iOS speech error:', e); window._iosUtterance = null; };
      
      window.speechSynthesis.speak(utterance);
      
      // Defensive resume for stalled synthesis
      if (window.speechSynthesis.paused) {
          window.speechSynthesis.resume();
      }
      return;
    }

    // For non-iOS, use NarbeVoiceManager if available
    if (window.NarbeVoiceManager) {
      const settings = window.NarbeVoiceManager.getSettings();
      console.log('NarbeVoiceManager settings:', settings);
      if (settings && settings.ttsEnabled) {
        console.log('Using NarbeVoiceManager');
        window.NarbeVoiceManager.speak(text);
        return;
      }
    }

    // Fallback for non-iOS if voice manager not available or disabled
    if (!isIOS && window.speechSynthesis) {
      console.log('Using fallback speech synthesis');
      window.speechSynthesis.cancel();
      const utterance = new SpeechSynthesisUtterance(text);
      window.speechSynthesis.speak(utterance);
    }
  }
  
  function isTTSEnabled() {
    if (window.NarbeVoiceManager) {
      const settings = window.NarbeVoiceManager.getSettings();
      return settings && settings.ttsEnabled;
    }
    return true; // Default to enabled if voice manager not available
  }

  // Robust exit helper: communicates with parent to focus back button
  // ====== Game flow ======
  function startNewGame() {
    stopAutoScan(); // Don't auto-scan during show phase
    sequence = [randInt(colorCount)];
    playerProgress = 0;
    round = 1;
    highlightIndex = -1; // Start with no highlight until spacebar is pressed
    phase = Phase.SHOWING;
    showSequence();
  }

  async function showSequence() {
    stopAutoScan();
    cancelBackScanIfAny();
    phase = Phase.SHOWING;
    // Don't speak here - it was already spoken in the user gesture
    // speak('Round ' + round);
    await sleep(1800); // wait longer so TTS finishes before sequence
    for (let i = 0; i < sequence.length; i++) {
      const idx = sequence[i];
      flashQuadrant(idx, 480);
      beep(idx, 460);
      await sleep(1060); // slowed by +0.5s (560 -> 1060)
    }
    playerProgress = 0;
    phase = Phase.PLAYER;
    startAutoScan(); // Resume auto-scan in player phase
  }

  function flashQuadrant(idx, dur) {
    const d = typeof dur === 'number' ? dur : 380;
    flashingIndex = idx;
    flashUntil = performance.now() + d;
  }

  function handlePlayerPick(pick) {
    if (phase !== Phase.PLAYER) return;
    flashQuadrant(pick, 300);
    beep(pick, 550);

    if (pick === sequence[playerProgress]) {
      playerProgress += 1;
      if (playerProgress === sequence.length) {
        round += 1;
        sequence.push(randInt(colorCount));
        // Speak the next round immediately while still in interaction context
        speak('Round ' + round);
        phase = Phase.SHOWING;
        setTimeout(showSequence, 320);
      } else {
        startAutoScan();
      }
    } else {
      phase = Phase.GAMEOVER;
      speakGameOverAndReturnToTitle();
    }
  }

  function speakGameOverAndReturnToTitle() {
    speak('Game over');
    setTimeout(() => {
      phase = Phase.MAIN;
      mainHighlight = -1; // No highlight until spacebar is pressed
      flashingIndex = -1;
      startAutoScan();
    }, 1500);
  }

  function exitApp() {
    speak('Exiting to Hub');
    setTimeout(() => {
      if (window.parent && window.parent !== window) {
        window.parent.postMessage({ action: 'focusBackButton' }, '*');
      } else {
        window.location.href = '../../../index.html';
      }
    }, 800);
  }

  function updateSettingsItems() {
    if (!window.NarbeScanManager) return;
    const s = window.NarbeScanManager.getSettings();
    const ttsEnabled = isTTSEnabled();
    settingsItems = [
      `TTS: ${ttsEnabled ? 'ON' : 'OFF'}`,
      `Audio: ${isAudioActive ? 'ON' : 'OFF'}`,
      `Auto Scan: ${s.autoScan ? 'ON' : 'OFF'}`,
      `Speed: ${s.scanInterval/1000}s`,
      'Back'
    ];
  }

  function handleSettingsAction() {
    if (!window.NarbeScanManager) return;
    if (settingsHighlight === 0) {
      // Toggle TTS via NarbeVoiceManager
      if (window.NarbeVoiceManager) {
        window.NarbeVoiceManager.toggleTTS();
      }
    } else if (settingsHighlight === 1) {
      // Toggle Audio
      isAudioActive = !isAudioActive;
    } else if (settingsHighlight === 2) {
      // Toggle auto scan
      const s = window.NarbeScanManager.getSettings();
      window.NarbeScanManager.setAutoScan(!s.autoScan);
    } else if (settingsHighlight === 3) {
      // Cycle speed
      window.NarbeScanManager.cycleScanSpeed();
    } else if (settingsHighlight === 4) {
      // Back
      phase = Phase.MAIN;
      mainHighlight = 1; // Defaults back to Settings
      startAutoScan();
    }
    updateSettingsItems();
    if (phase === Phase.SETTINGS && settingsHighlight < settingsItems.length) {
       speak(settingsItems[settingsHighlight]);
    }
    // Update active auto scan
    if (window.NarbeScanManager.getSettings().autoScan) {
       startAutoScan();
    } else {
       stopAutoScan();
    }
  }

  window.addEventListener('keydown', async (e) => {
    if (e.code === 'Space') e.preventDefault();
    if (e.repeat) return;
    
    // Stop auto-scan on user input
    stopAutoScan();
    
    // Initialize and resume audio on first user interaction
    await unlockAudio();
    
    if (e.code === 'Space') {
      if (!(phase === Phase.PLAYER || phase === Phase.MAIN || phase === Phase.DIFFICULTY || phase === Phase.SETTINGS)) return;
      if (!spaceIsDown) {
        spaceIsDown = true;
        spaceDownAt = performance.now();
        cancelBackScanIfAny();
        if (backScanTimer) clearTimeout(backScanTimer);
        backScanTimer = setTimeout(() => {
          if (spaceIsDown && (performance.now() - spaceDownAt >= BACK_HOLD_THRESHOLD)) {
            isBackScanActive = true;
            const interval = window.NarbeScanManager ? window.NarbeScanManager.getScanInterval() : 1500;
            backScanInterval = setInterval(() => { stepBackward(); }, interval);
          }
        }, BACK_HOLD_THRESHOLD);
      }
    }
  });

  window.addEventListener('keyup', (e) => {
    if (e.code === 'Space') {
      e.preventDefault();
      if (!(phase === Phase.PLAYER || phase === Phase.MAIN || phase === Phase.DIFFICULTY || phase === Phase.SETTINGS)) { cancelBackScanIfAny(); return; }
      if (isBackScanActive) {
        cancelBackScanIfAny();
      } else {
        const now = performance.now();
        if (now - lastForwardStepAt >= FORWARD_DEBOUNCE) {
          stepForward();
          lastForwardStepAt = now;
        }
      }
      spaceIsDown = false;
      spaceDownAt = 0;
    }

    if (e.code === 'Enter') {
      const now = performance.now();
      if (now - lastReturnAt < RETURN_DEBOUNCE) return;
      lastReturnAt = now;

      if (phase === Phase.MAIN) {
        if (mainHighlight >= 0 && mainHighlight < MAIN_MENU_ITEMS.length) {
          const sel = MAIN_MENU_ITEMS[mainHighlight];
          if (sel === 'Play Game') {
             // iOS Audio Unlock Intent
             beep(0, 60);
             
             phase = Phase.DIFFICULTY;
             diffHighlight = -1;
             speak('Select Difficulty');
             startAutoScan();
          } else if (sel === 'Settings') {
             phase = Phase.SETTINGS;
             settingsHighlight = 0;
             updateSettingsItems();
             speak('Settings');
             speak(settingsItems[0]);
             startAutoScan();
          } else if (sel === 'Exit Game') {
             exitApp();
          }
        }
        return;
      }

      if (phase === Phase.DIFFICULTY) {
        if (diffHighlight >= 0 && diffHighlight < DIFFICULTY_ITEMS.length) {
          const sel = DIFFICULTY_ITEMS[diffHighlight];
          if (sel === 'Back') {
             phase = Phase.MAIN;
             mainHighlight = 0;
             speak('Main Menu');
             startAutoScan();
          } else {
             // Speak Round 1 immediately in the user gesture before any delays
             speak('Round 1');
             colorCount = sel === 'Easy' ? 2 : (sel === 'Medium' ? 3 : 4);
             startNewGame();
          }
        }
        return;
      }

      if (phase === Phase.SETTINGS) {
         if (settingsHighlight >= 0) handleSettingsAction();
         return;
      }

      if (phase === Phase.SHOWING) return;
      if (phase === Phase.GAMEOVER) return;

      if (phase === Phase.PLAYER) {
        if (highlightIndex >= 0 && highlightIndex < colorCount) handlePlayerPick(highlightIndex);
      }
    }
  });

  // Mouse input
  canvas.addEventListener('click', async (e) => {
    // Initialize and resume audio on first user interaction
    await unlockAudio();
    
    // Stop any remnant audio that might be playing
    audioElements.forEach(el => {
      try { el.pause(); el.currentTime = 0; } catch (e) {}
    });
    
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    if (phase === Phase.MAIN) {
      for (let i = 0; i < menuBounds.length; i++) {
        const b = menuBounds[i];
        if (x >= b.x && x <= b.x + b.w && y >= b.y && y <= b.y + b.h) {
          const sel = MAIN_MENU_ITEMS[i];
          if (sel === 'Play Game') {
             // iOS Audio Unlock Intent - SKIP beep to avoid TTS conflict
             // beep(0, 60);
             
             phase = Phase.DIFFICULTY;
             diffHighlight = -1;
             speak('Select Difficulty');
             startAutoScan();
          } else if (sel === 'Settings') {
             phase = Phase.SETTINGS;
             settingsHighlight = 0;
             updateSettingsItems();
             speak('Settings');
             speak(settingsItems[0]);
             startAutoScan();
          } else if (sel === 'Exit Game') {
             exitApp();
          }
          return;
        }
      }
    } else if (phase === Phase.DIFFICULTY) {
      for (let i = 0; i < menuBounds.length; i++) {
        const b = menuBounds[i];
        if (x >= b.x && x <= b.x + b.w && y >= b.y && y <= b.y + b.h) {
           const sel = DIFFICULTY_ITEMS[i];
           if (sel === 'Back') {
             phase = Phase.MAIN;
             mainHighlight = 0;
             speak('Main Menu');
             startAutoScan();
           } else {
             // Speak Round 1 immediately in the user gesture before any delays
             speak('Round 1');
             colorCount = sel === 'Easy' ? 2 : (sel === 'Medium' ? 3 : 4);
             startNewGame();
           }
           return;
        }
      }
    } else if (phase === Phase.SETTINGS) {
       for (let i=0; i < menuBounds.length; i++) {
         const b = menuBounds[i];
         if (x >= b.x && x <= b.x + b.w && y >= b.y && y <= b.y + b.h) {
           settingsHighlight = i;
           handleSettingsAction();
           return;
         }
       }
    } else if (phase === Phase.PLAYER) {
      // Check tile clicks
      for (let i = 0; i < tileBounds.length; i++) {
        const b = tileBounds[i];
        if (x >= b.x && x <= b.x + b.w && y >= b.y && y <= b.y + b.h) {
          handlePlayerPick(i);
          return;
        }
      }
    }
  });

  // Touch input for iOS
  canvas.addEventListener('touchstart', async (e) => {
    e.preventDefault(); // Prevent scrolling
    
    // Initialize and resume audio on first user interaction
    await unlockAudio();

    // Stop and clear any lingering audio before processing logic/speech
    audioElements.forEach(el => {
        try { el.pause(); el.currentTime = 0; } catch (e) {}
    });
    
    if (e.touches.length === 0) return;
    const touch = e.touches[0];
    const rect = canvas.getBoundingClientRect();
    const x = touch.clientX - rect.left;
    const y = touch.clientY - rect.top;

    if (phase === Phase.MAIN) {
      for (let i = 0; i < menuBounds.length; i++) {
        const b = menuBounds[i];
        if (x >= b.x && x <= b.x + b.w && y >= b.y && y <= b.y + b.h) {
          const sel = MAIN_MENU_ITEMS[i];
          if (sel === 'Play Game') {
             // iOS Audio Unlock Intent - SKIP beep to avoid TTS conflict
             // beep(0, 60);
             
             phase = Phase.DIFFICULTY;
             diffHighlight = -1;
             speak('Select Difficulty');
             startAutoScan();
          } else if (sel === 'Settings') {
             phase = Phase.SETTINGS;
             settingsHighlight = 0;
             updateSettingsItems();
             speak('Settings');
             speak(settingsItems[0]);
          } else if (sel === 'Exit Game') {
             exitApp();
          }
          return;
        }
      }
    } else if (phase === Phase.DIFFICULTY) {
      for (let i = 0; i < menuBounds.length; i++) {
        const b = menuBounds[i];
        if (x >= b.x && x <= b.x + b.w && y >= b.y && y <= b.y + b.h) {
          const sel = DIFFICULTY_ITEMS[i];
          if (sel === 'Back') {
             phase = Phase.MAIN;
             mainHighlight = 0;
             speak('Main Menu');
             startAutoScan();
          } else {
             // Speak Round 1 immediately in the user gesture before any delays
             speak('Round 1');
             colorCount = sel === 'Easy' ? 2 : (sel === 'Medium' ? 3 : 4);
             startNewGame();
          }
          return;
        }
      }
    } else if (phase === Phase.SETTINGS) {
       for (let i=0; i < menuBounds.length; i++) {
         const b = menuBounds[i];
         if (x >= b.x && x <= b.x + b.w && y >= b.y && y <= b.y + b.h) {
           settingsHighlight = i;
           handleSettingsAction();
           return;
         }
       }
    } else if (phase === Phase.PLAYER) {
      // Check tile touches
      for (let i = 0; i < tileBounds.length; i++) {
        const b = tileBounds[i];
        if (x >= b.x && x <= b.x + b.w && y >= b.y && y <= b.y + b.h) {
          handlePlayerPick(i);
          return;
        }
      }
    }
  });

  function cancelBackScanIfAny() {
    if (backScanTimer) { clearTimeout(backScanTimer); backScanTimer = null; }
    if (backScanInterval) { clearInterval(backScanInterval); backScanInterval = null; }
    isBackScanActive = false;
  }

  function stepForward() {
    if (phase === Phase.PLAYER) {
      if (highlightIndex === -1) {
        highlightIndex = 0; // First press: go from no highlight to first button
      } else {
        highlightIndex = (highlightIndex + 1) % colorCount;
      }
    } else if (phase === Phase.MAIN) {
      if (mainHighlight === -1) {
         mainHighlight = 0;
      } else {
         mainHighlight = (mainHighlight + 1) % MAIN_MENU_ITEMS.length;
      }
      speak(MAIN_MENU_ITEMS[mainHighlight]);
    } else if (phase === Phase.DIFFICULTY) {
      if (diffHighlight === -1) {
        diffHighlight = 0;
      } else {
        diffHighlight = (diffHighlight + 1) % DIFFICULTY_ITEMS.length;
      }
      speak(DIFFICULTY_ITEMS[diffHighlight]);
    } else if (phase === Phase.SETTINGS) {
      settingsHighlight = (settingsHighlight + 1) % settingsItems.length;
      speak(settingsItems[settingsHighlight]);
    }
  }

  function stepBackward() {
    if (phase === Phase.PLAYER) {
      if (highlightIndex === 0) {
        highlightIndex = -1; // Go back to no highlight
      } else if (highlightIndex === -1) {
        highlightIndex = colorCount - 1; // Wrap to last button
      } else {
        highlightIndex = (highlightIndex - 1 + colorCount) % colorCount;
      }
    } else if (phase === Phase.MAIN) {
      if (mainHighlight === -1) {
          mainHighlight = MAIN_MENU_ITEMS.length - 1;
      } else {
          mainHighlight = (mainHighlight - 1 + MAIN_MENU_ITEMS.length) % MAIN_MENU_ITEMS.length;
      }
      speak(MAIN_MENU_ITEMS[mainHighlight]);
    } else if (phase === Phase.DIFFICULTY) {
      if (diffHighlight === -1) {
         diffHighlight = DIFFICULTY_ITEMS.length - 1;
      } else {
         diffHighlight = (diffHighlight - 1 + DIFFICULTY_ITEMS.length) % DIFFICULTY_ITEMS.length;
      }
      speak(DIFFICULTY_ITEMS[diffHighlight]);
    } else if (phase === Phase.SETTINGS) {
      settingsHighlight = (settingsHighlight - 1 + settingsItems.length) % settingsItems.length;
      speak(settingsItems[settingsHighlight]);
    }
  }

  // ====== Render ======
  function draw() {
    try {
      const rect = canvas.getBoundingClientRect();
      const w = Math.max(1, Math.floor(rect.width || canvas.width / DPR || window.innerWidth || 800));
      const h = Math.max(1, Math.floor(rect.height || canvas.height / DPR || window.innerHeight || 600));

      // Clear
      ctx.fillStyle = BG;
      ctx.fillRect(0, 0, w, h);

      // Title / Score
      ctx.fillStyle = '#e5e7eb';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      ctx.font = '700 28px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';

      if (phase === Phase.MAIN) {
        // Title
        ctx.fillText('Benny Says', w/2, 24);

        // Big menu buttons
        menuBounds = [];
        const mx = 20; const mw = w - 40;
        const startY = 90;
        const rows = MAIN_MENU_ITEMS.length;
        const btnH = Math.max(72, Math.floor((h - startY - 120) / (rows + 0.3)));
        const gap = Math.max(14, Math.floor(btnH * 0.16));
        for (let i = 0; i < rows; i++) {
          const y = startY + i * (btnH + gap);
          const isSel = (i === mainHighlight);
          const radius = 18;
          
          // Store bounds for mouse detection
          menuBounds.push({x: mx, y: y, w: mw, h: btnH});
          
          let color = MAIN_COLORS[i];
          if (MAIN_MENU_ITEMS[i] === 'Exit Game') color = '#ef4444'; // Keep Exit red

          ctx.fillStyle = color;
          roundRect(mx, y, mw, btnH, radius);
          ctx.fill();
          if (isSel) {
            ctx.save();
            ctx.lineWidth = 8; ctx.strokeStyle = 'rgba(255,255,255,0.98)';
            ctx.shadowBlur = 22; ctx.shadowColor = 'rgba(255,255,255,0.9)';
            roundRect(mx, y, mw, btnH, radius);
            ctx.stroke();
            ctx.restore();
          }
          ctx.fillStyle = '#0b2239';
          ctx.font = '800 24px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
          ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
          ctx.fillText(MAIN_MENU_ITEMS[i], mx + mw/2, y + btnH/2);
        }

        ctx.font = '400 14px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillStyle = '#e5e7eb';
        ctx.fillText('Space = scan, Return = select, Click = direct select', w/2, startY + rows*(btnH+gap) + 8);

      } else if (phase === Phase.DIFFICULTY) {
        ctx.fillText('Select Difficulty', w/2, 24);

        menuBounds = [];
        const mx = 20; const mw = w - 40;
        const startY = 90;
        const rows = DIFFICULTY_ITEMS.length;
        const btnH = Math.max(72, Math.floor((h - startY - 120) / (rows + 0.3)));
        const gap = Math.max(14, Math.floor(btnH * 0.16));
        for (let i = 0; i < rows; i++) {
          const y = startY + i * (btnH + gap);
          const isSel = (i === diffHighlight);
          const radius = 18;
          
          // Store bounds for mouse detection
          menuBounds.push({x: mx, y: y, w: mw, h: btnH});
          
          ctx.fillStyle = DIFFICULTY_COLORS[i];
          roundRect(mx, y, mw, btnH, radius);
          ctx.fill();
          if (isSel) {
            ctx.save();
            ctx.lineWidth = 8; ctx.strokeStyle = 'rgba(255,255,255,0.98)';
            ctx.shadowBlur = 22; ctx.shadowColor = 'rgba(255,255,255,0.9)';
            roundRect(mx, y, mw, btnH, radius);
            ctx.stroke();
            ctx.restore();
          }
          ctx.fillStyle = '#0b2239';
          ctx.font = '800 24px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
          ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
          ctx.fillText(DIFFICULTY_ITEMS[i], mx + mw/2, y + btnH/2);
        }
      } else if (phase === Phase.SETTINGS) {
        ctx.fillText('Settings', w/2, 24);

        menuBounds = [];
        const mx = 20; const mw = w - 40;
        const startY = 80;
        const rows = settingsItems.length;
        const btnH = 60;
        const gap = 16;
        for (let i = 0; i < rows; i++) {
          const y = startY + i * (btnH + gap);
          const isSel = (i === settingsHighlight);
          
          menuBounds.push({x: mx, y: y, w: mw, h: btnH});
          
          ctx.fillStyle = '#334155'; // Slate 700
          roundRect(mx, y, mw, btnH, 12);
          ctx.fill();
          if (isSel) {
            ctx.save();
            ctx.lineWidth = 4; ctx.strokeStyle = '#38bdf8'; // Sky 400
            ctx.shadowBlur = 10; ctx.shadowColor = '#0ea5e9';
            roundRect(mx, y, mw, btnH, 12);
            ctx.stroke();
            ctx.restore();
          }
          ctx.fillStyle = '#f8fafc';
          ctx.font = '700 20px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
          ctx.textAlign = 'left'; ctx.textBaseline = 'middle';
          ctx.fillText(settingsItems[i], mx + 24, y + btnH/2);
        }
      } else if (phase === Phase.GAMEOVER) {
        ctx.fillText('Game Over', w/2, 24);
        ctx.font = '400 16px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
        ctx.fillText('Returning to menu...', w/2, 60);

      } else {
        ctx.fillText('Round ' + round, w/2, 24);

        // Gameplay tiles (fill screen based on colorCount)
        tileBounds = [];
        const pad = 16;
        if (colorCount === 2) {
          const gap = 12; const bx = pad; const bw = (w - pad*2 - gap) / 2;
          const by = 64; const bh = h - by - pad;
          drawTile(0, {x: bx, y: by, w: bw, h: bh});
          drawTile(1, {x: bx + bw + gap, y: by, w: bw, h: bh});
        } else if (colorCount === 3) {
          const gap = 12; const bw = (w - pad*2 - gap*2) / 3;
          const by = 64; const bh = h - by - pad;
          drawTile(0, {x: pad, y: by, w: bw, h: bh});
          drawTile(1, {x: pad + bw + gap, y: by, w: bw, h: bh});
          drawTile(2, {x: pad + (bw + gap) * 2, y: by, w: bw, h: bh});
        } else {
          const gap = 12; const by = 64;
          const bh = (h - by - pad - gap) / 2; const bw = (w - pad*2 - gap) / 2;
          drawTile(0, {x: pad, y: by, w: bw, h: bh});
          drawTile(1, {x: pad + bw + gap, y: by, w: bw, h: bh});
          drawTile(2, {x: pad, y: by + bh + gap, w: bw, h: bh});
          drawTile(3, {x: pad + bw + gap, y: by + bh + gap, w: bw, h: bh});
        }
      }

      if (flashingIndex !== -1 && performance.now() >= flashUntil) {
        flashingIndex = -1;
      }

    } catch (err) {
      // Visible error message on canvas
      ctx.fillStyle = '#111827'; ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = '#ef4444';
      ctx.font = '600 16px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
      ctx.textAlign = 'left'; ctx.textBaseline = 'top';
      ctx.fillText('Render error: ' + (err && err.message ? err.message : String(err)), 12, 12);
    }
    requestAnimationFrame(draw);
  }

  function drawTile(i, q) {
    // Store bounds for mouse detection
    tileBounds.push({x: q.x, y: q.y, w: q.w, h: q.h});
    
    const now = performance.now();
    const isFlash = (i === flashingIndex) && (now < flashUntil);
    const color = COLORS[i];

    ctx.fillStyle = isFlash ? lighten(color, FLASH_LIGHTEN) : color;
    roundRect(q.x, q.y, q.w, q.h, 28); ctx.fill();

    if (phase === Phase.PLAYER && highlightIndex === i) {
      ctx.save();
      ctx.lineWidth = 12; ctx.strokeStyle = 'rgba(255,255,255,0.98)';
      ctx.shadowBlur = 28; ctx.shadowColor = 'rgba(255,255,255,0.95)';
      roundRect(q.x, q.y, q.w, q.h, 30); ctx.stroke();
      ctx.restore();
    }

    ctx.fillStyle = '#0b2239';
    ctx.font = '800 28px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.fillText(NAMES[i], q.x + q.w/2, q.y + q.h/2);
  }

  function roundRect(x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
  }

  function lighten(hex, amt) {
    const a = typeof amt === 'number' ? amt : 0.3;
    const c = hex.replace('#','');
    const r = parseInt(c.slice(0,2),16);
    const g = parseInt(c.slice(2,4),16);
    const b = parseInt(c.slice(4,6),16);
    const lr = Math.min(255, Math.floor(r + (255 - r) * a));
    const lg = Math.min(255, Math.floor(g + (255 - g) * a));
    const lb = Math.min(255, Math.floor(b + (255 - b) * a));
    return '#' + lr.toString(16).padStart(2,'0') + lg.toString(16).padStart(2,'0') + lb.toString(16).padStart(2,'0');
  }

  // Check NarbeScanManager on load for auto-scan
  window.addEventListener('load', () => {
    console.log('Page loaded, NarbeVoiceManager available:', !!window.NarbeVoiceManager);
    console.log('speechSynthesis available:', !!window.speechSynthesis);
    
    // Initialize audio on load
    initAudio();
    
    // Test TTS on load (will only work on non-iOS or after user interaction)
    if (!isIOS) {
      setTimeout(() => speak('Benny Says loaded'), 1000);
    }
    
    if (window.NarbeScanManager) {
      if (window.NarbeScanManager.getSettings().autoScan) {
        startAutoScan();
      }
      // Listen for changes
      window.NarbeScanManager.subscribe((s) => {
         updateSettingsItems();
         if (s.autoScan) {
             startAutoScan();
         } else {
             stopAutoScan();
         }
      });
    }
  });

  // Start
  requestAnimationFrame(draw);
  </script>
</body>
</html>